# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Quickly verify (and locate) the existence of a breach.
#' @name AnyWhich
#' @description Used when a single instance is likely to occur and be important to detect quickly
#' (in a sufficiently large integer vector).
#' @param x An integer vector.
#' @param a A (single) integer. That which is to be compared.
#' @param gt,lt,eq Booleans, whether or not the comparison is greater than, less than, or equal to.
#' Only \code{gt} and \code{lt} are mutually exclusive.
NULL

AnyWhich <- function(x, a, gt, lt, eq) {
    .Call(`_grattan_AnyWhich`, x, a, gt, lt, eq)
}

#' @title IncomeTax
#' @description Calculates the ordinary tax payable given income and tax thresholds and rates.
#' Basic, designed for performance.
#' @name IncomeTax
#' @param x Taxable income.
#' @param thresholds Lower brackets of the tax tables.
#' @param rates Marginal rates
#' @export IncomeTax
NULL

IncomeTax <- function(x, thresholds, rates) {
    .Call(`_grattan_IncomeTax`, x, thresholds, rates)
}

#' @title Medicare levy in C++
#' @description Medicare levy. Experimental function in C++, equivalent to \code{\link{medicare_levy}}.
#' @name MedicareLevy
#' @param income,SpouseIncome,isFamily,NDependants,lowerThreshold,upperThreshold,lowerFamilyThreshold,upperFamilyThreshold,lowerUpForEachChild As in \code{medicare_levy}.
#' @param rate,taper The parameters for the specific year or hypothetical requested.
#' @export MedicareLevy
#' @details For \code{yr > 2018}, the 2017-18 values are used.
NULL

MedicareLevySingle <- function(income, lowerThreshold, upperThreshold, rate = 0.02, taper = 0.1, SpouseIncome = 0, isFamily = FALSE, nDependants = 0L, lowerFamilyThreshold = 46000, upperFamilyThreshold = 54119, lowerUpForEachChild = 3306) {
    .Call(`_grattan_MedicareLevySingle`, income, lowerThreshold, upperThreshold, rate, taper, SpouseIncome, isFamily, nDependants, lowerFamilyThreshold, upperFamilyThreshold, lowerUpForEachChild)
}

MedicareLevySaptoYear <- function(income, SpouseIncome, NDependants, SaptoEligible, yr) {
    .Call(`_grattan_MedicareLevySaptoYear`, income, SpouseIncome, NDependants, SaptoEligible, yr)
}

MedicareLevy <- function(income, lowerThreshold, upperThreshold, SpouseIncome, isFamily, NDependants, lowerFamilyThreshold, upperFamilyThreshold, lowerUpForEachChild, rate, taper) {
    .Call(`_grattan_MedicareLevy`, income, lowerThreshold, upperThreshold, SpouseIncome, isFamily, NDependants, lowerFamilyThreshold, upperFamilyThreshold, lowerUpForEachChild, rate, taper)
}

#' @title General offset in C++
#' @name Offset
#' @description Calculate the offset given a threshold, a maximum offset, and a taper. 
#' @param x A vector of incomes etc.
#' @param y The maximum offset available; the offset when \code{x} is zero.
#' @param a The maximum value of \code{x} at which the maximum offset is available.
#' @param m The taper rate (the \strong{negative} slope).
#' @export Offset
NULL

#' @name MultiOffset
#' @title Multioffset
#' @description An offset with multiple thresholds and tapers.
#' 
#' @param x A numeric vector that the thresholds refer to.
#' @param first_offset \code{numeric(1)} The value of the first offset,
#' the value of the offset for \code{x < first(thresholds)}.
#' @param thresholds The thresholds for changes in the offset.
#' @param tapers The tapers that apply \strong{above} the corresponding element
#' of \code{thresholds}.
#' @param above_zero (bool) Should negative offsets be set to zero?
#' 
#' 
#' @examples
#' MultiOffset(c(36e3, 37e3, 38e3, 47e3, 48e3, 49e3), 
#'             255,
#'             c(37e3, 48e3, 90e3),
#'             c(0.075, 0, -0.03))
NULL

Offset <- function(x, y, a, m) {
    .Call(`_grattan_Offset`, x, y, a, m)
}

MultiOffset <- function(x, first_offset, thresholds, tapers, above_zero = TRUE) {
    .Call(`_grattan_MultiOffset`, x, first_offset, thresholds, tapers, above_zero)
}

anyOutside <- function(x, a, b) {
    .Call(`_grattan_anyOutside`, x, a, b)
}

#' @name do_income_tax
#' @description Accepts a sample file-like List and a tax year and returns
#' a double vector.
#' 
#' @param c_age_30_june Age of taxpayer at 30 June of the financial year.
#' @param is_net_rent Net rent amount.
#' @param it_invest_loss Net financial income loss.
#' @param 
#' 
NULL

do_lito <- function(x, yr) {
    .Call(`_grattan_do_lito`, x, yr)
}

do_lmito <- function(x) {
    .Call(`_grattan_do_lmito`, x)
}

verify_NA_ALIAS <- function(x = 0L) {
    .Call(`_grattan_verify_NA_ALIAS`, x)
}

do_income_tax_sf <- function(yr, N, ic_taxable_income_loss, c_age_30_june, is_net_rent, it_property_loss, it_rept_empl_super_cont, it_rept_fringe_benefit, it_invest_loss, spc_rebate_income, partner_status) {
    .Call(`_grattan_do_income_tax_sf`, yr, N, ic_taxable_income_loss, c_age_30_june, is_net_rent, it_property_loss, it_rept_empl_super_cont, it_rept_fringe_benefit, it_invest_loss, spc_rebate_income, partner_status)
}

#' @title Threeway parallel maximum
#' @description Returns the parallel maximum of three 
#' 
#' @name pmax3
#' @param x,y,z Numeric vectors of identical lengths.
#' @return The parallel maximum of the vectors.
#' @export pmax3
NULL

pmax3 <- function(x, y, z) {
    .Call(`_grattan_pmax3`, x, y, z)
}

#' @title Parallel maximum
#' @description A faster \code{pmax()}.
#'
#' @name pmaxC
#' @param x A numeric vector.
#' @param a A single numeric value.
#' @return The parallel maximum of the input values. \code{pmax0(x)} is
#'  shorthand for \code{pmaxC(x, 0)}, i.e. convert negative values in \code{x} to 0.
#' @note This function will always be faster than \code{pmax(x, a)} when \code{a} is
#'  a single value, but can be slower than \code{pmax.int(x, a)} when \code{x} is short.
#'  Use this function when comparing a numeric vector with a single value.
#' @export pmaxC
NULL

pmaxC <- function(x, a) {
    .Call(`_grattan_pmaxC`, x, a)
}

pmaxCint <- function(x, a) {
    .Call(`_grattan_pmaxCint`, x, a)
}

pmax0 <- function(x) {
    .Call(`_grattan_pmax0`, x)
}

pmaxIPnum0 <- function(x) {
    .Call(`_grattan_pmaxIPnum0`, x)
}

pmaxIPint0 <- function(x) {
    .Call(`_grattan_pmaxIPint0`, x)
}

#' @title Parallel maximum
#' @description A faster \code{pmax()}.
#'
#' @name pmaxV
#' @param x A numeric vector.
#' @param y A numeric vector, the same length as x.
#' @return The parallel maximum of the input values.
#' @export pmaxV
NULL

pmaxV <- function(x, y) {
    .Call(`_grattan_pmaxV`, x, y)
}

#' @title Parallel maximum
#' @description A faster \code{pmin()}.
#'
#' @name pminC
#' @param x A numeric vector.
#' @param a A single numeric value.
#' @return The parallel minimum of the input values. The \code{0} versions are shortcuts for \code{a = 0}.
#' @note This function will always be faster than \code{pmin(x, a)} when \code{a} is a single value, but can be slower than \code{pmin.int(x, a)} when \code{x} is short. Use this function when comparing a numeric vector with a single value.
#' @export pminC
NULL

pminC <- function(x, a) {
    .Call(`_grattan_pminC`, x, a)
}

pmin0 <- function(x) {
    .Call(`_grattan_pmin0`, x)
}

#' @title Parallel maximum
#' @description A faster \code{pmin()}.
#'
#' @name pminV
#' @param x A numeric vector.
#' @param y A numeric vector, the same length as x.
#' @return The parallel maximum of the input values.
#' @export pminV
NULL

pminV <- function(x, y) {
    .Call(`_grattan_pminV`, x, y)
}

do_sapto_rcpp <- function(RebateIncome, MaxOffset, LowerThreshold, TaperRate, SaptoEligible, SpouseIncome, IsMarried) {
    .Call(`_grattan_do_sapto_rcpp`, RebateIncome, MaxOffset, LowerThreshold, TaperRate, SaptoEligible, SpouseIncome, IsMarried)
}

do_sapto_rcpp2 <- function(RebateIncome, maxOffsetSingle, maxOffsetMarried, lowerThresholdSingle, lowerThresholdMarried, taperRateSingle, taperRateMarried, SaptoEligible, IsMarried, SpouseIncome) {
    .Call(`_grattan_do_sapto_rcpp2`, RebateIncome, maxOffsetSingle, maxOffsetMarried, lowerThresholdSingle, lowerThresholdMarried, taperRateSingle, taperRateMarried, SaptoEligible, IsMarried, SpouseIncome)
}

#' SAPTO singleton
#' @name sapto_rcpp_singleton
#' @description Length-one version of \code{SAPTO} in C++.
#' @param rebate_income,max_offset,lower_threshold,taper_rate,sapto_eligible,Spouse_income,is_married As in \code{\link{sapto}}.
#' @export
sapto_rcpp_singleton <- function(rebate_income, max_offset, lower_threshold, taper_rate, sapto_eligible, Spouse_income, is_married) {
    .Call(`_grattan_sapto_rcpp_singleton`, rebate_income, max_offset, lower_threshold, taper_rate, sapto_eligible, Spouse_income, is_married)
}

#' @title SAPTO for specific years in C++
#' @name sapto_rcpp_yr
#' @description Fast way to calculate SAPTO for multiple people when the year is known in advance. Speed is by cheating and entering in the year's parameters literally.
#' @param RebateIncome,IsMarried,SpouseIncome As in \code{\link{sapto}}.
#' @export sapto_rcpp_yr
NULL

sapto_rcpp_yr_singleton <- function(rebateIncome, isMarried, spouseIncome, yr) {
    .Call(`_grattan_sapto_rcpp_yr_singleton`, rebateIncome, isMarried, spouseIncome, yr)
}

sapto_rcpp_yr <- function(RebateIncome, SpouseIncome, IsMarried, yr) {
    .Call(`_grattan_sapto_rcpp_yr`, RebateIncome, SpouseIncome, IsMarried, yr)
}

