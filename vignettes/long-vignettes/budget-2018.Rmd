---
title: "Budget 2018 modelling"
author: "Hugh Parsonage"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    toc: true
    toc_depth: 4
    keep_md: true
---



```{r setup, include = FALSE, cache=TRUE}
options(width = 110) # for kables (?)
knitr::opts_chunk$set(
  collapse = TRUE,
  error = FALSE,
  comment = "#>",
  fig.width = 9,
  fig.height = 7,
  dev = "svg",
  fig.path = "./Budget2018-atlas/"
)
options("warn" = 2)
if (!exists("cache")) {
  library(magrittr)
  library(hutils)
  .daysSinceCacheRefresh <- function(x) {
    as.double(difftime(Sys.time(), file.mtime(x), units = "days"))
  }
  caches.fst <-
    dir(path = "budget-2018_cache/", 
        pattern = "\\.fst$", 
        full.names = TRUE)
  
  cache <-
    OR(!length(caches.fst), # if cache empty, write
        vapply(dir(path = "budget-2018_cache/", 
                   pattern = "\\.fst$", 
                   full.names = TRUE), 
               .daysSinceCacheRefresh, 
               double(1L)) %>%
          max %>%
          is_less_than(91))
}
if (FALSE) {
  if (interactive() && !grattanCharts::is_knitting()) {
    stopifnot(file.exists("~/grattan/DESCRIPTION"))
    stopifnot(file.exists("budget-2018.Rmd"))
    pkgdown::build_site(pkg = "../..", lazy = TRUE)
    for (svg in dir(path = "~/grattan/vignettes/long-vignettes/Budget2018-atlas/", 
                    pattern = "\\.svg$", 
                    full.names = TRUE)) {
      
      file.copy(svg,
                file.path("~/grattan/docs/articles/long-vignettes/Budget2018-atlas/", 
                          basename(svg)))
      file.copy(svg,
                file.path("~/grattan/docs/articles/long-vignettes/budget-2018_files/", 
                          basename(svg)))
    }
    
    for (svg in dir(path = "~/grattan/docs/articles/",
                    full.names = TRUE,
                    recursive = TRUE,
                    pattern = "\\.png$")) {
      if (!file.rename(svg, sub("\\.png$", ".svg", svg))) {
        stop(svg)
      }
    }

    
    change_pngs <- function(html) {
      html_lines <- readr::read_lines(html)
      for (i in grep("((grattan_files/figure.html)|(Budget2018.atlas)|(budget.2018_files)|(compare.30.37.42.thresholds.1)).*\\.png", html_lines)) {
        html_lines[i] <- sub(".png", ".svg", html_lines[i], fixed = TRUE)
      }
      readr::write_lines(html_lines, html)
    }
    invisible(lapply(dir(path = "~/grattan/docs/articles/long-vignettes/", 
                         pattern = "\\.html$", 
                         full.names = TRUE), 
                     change_pngs))
    invisible(lapply(dir(path = "~/grattan/docs/articles/", 
                         pattern = "\\.html$", 
                         full.names = TRUE), 
                     change_pngs))
    invisible(lapply(dir(path = "~/grattan/docs/", 
                         pattern = "\\.html$", 
                         full.names = TRUE), 
                     change_pngs))
    (all(vapply(setdiff(dir(path = "~/grattan/vignettes/long-vignettes/",
                            full.names = TRUE,
                            recursive = TRUE,
                            pattern = "\\.png$"),
                        dir(path = "~/grattan/vignettes/long-vignettes/",
                            pattern = "(twitter|[-]1)\\.png$",
                            full.names = TRUE,
                            recursive = TRUE)),
                file.remove,
                FALSE)))
    
    
  }
}

START.TIME <- Sys.time()
if (FALSE && isTRUE(getOption("knitr.in.progress"))) {
  BUNDLE.CHART.DATA <- FALSE
  .finished <- FALSE
  chunktimings.txt <- "budget-2018-chunktimings.txt"
  invisible(file.create(chunktimings.txt))
  mem_usage.tsv <- "budget-2018-memory-usage.tsv"
  mem_usage_tempfile <- tempfile("mem")
  invisible(file.create(mem_usage.tsv))
  knitr::knit_hooks$set(timeit = function(before) {
    if (before) {
      utils::Rprofmem(mem_usage_tempfile)
      assign(".current.time", value = Sys.time(), envir = .GlobalEnv)
    } else {
      .duration <- formatC(as.numeric(round(difftime(Sys.time(), 
                                                     .current.time, units = "secs"), 1)), format = "f", 
                           flag = "#", digits = 1, width = 5)
      if (!.finished) {
        write(paste0(.duration, "\t", knitr::opts_current$get(name = "label")), 
              file = chunktimings.txt, ncolumns = 1, append = TRUE)
      }
      utils::Rprofmem(NULL)
      .mem_used <-
        profmem::readRprofmem(mem_usage_tempfile) %$%
        sum(as.double(bytes), na.rm = TRUE) %>%
        divide_by(1024^3) %>%
        round(1) %>%
        formatC(digits = 1, width = 4, format = "f")
      write(paste0(.mem_used,
                   "\t",
                   knitr::opts_current$get(name = "label")),
            file = mem_usage.tsv,
            ncolumns = 1,
            append = TRUE)
    }
  })
  knitr::opts_chunk$set(timeit = TRUE)
}
```

```{r RUNTIME-CHECKS}
stopifnot(file.exists("../../DESCRIPTION"))
stopifnot(!isFALSE(getOption("knitr.use.stringr")))
```

```{r fwrite}
# New fwriter so that git checkins are not too bad:
fwrite <- function(x, file, ...) {
  xo <- copy(x)
  for (j in seq_along(x)) {
    xj <- x[[j]]
    if (is.double(xj)) {
      jmax <- max(xj, na.rm = TRUE)
      jmin <- min(xj, na.rm = TRUE)
      if (jmax < 1 && jmin > -1) {
        set(xo, j = j, value = round(xj, 4))
      } else if (abs(jmin) > 100e3) {
        set(xo, j = j, value = round(xj, -3))
      } else {
        set(xo, j = j, value = round(xj, 1))
      }
    }
  }
  data.table::fwrite(xo, file, ...)
  
}

```

```{r grattan_percent}
grattan_percent <- function(number, digits = 1, .percent.suffix = " per cent") {
  grattanCharts::grattan_percent(number, digits, .percent.suffix)
}
```

## Introduction

This article outlines the calculations used in Grattan Institute's tax modelling. 
The model is simple:

1. Project ("uprate") the latest sample files to the years required
2. Use `model_income_tax` with the required parameters. 


First load the packages we'll need.



```{r loadPackages}
library(fst)
library(fastmatch)
library(ggplot2)
library(scales)
library(magrittr)
library(ggrepel)
library(viridis)
library(knitr)
library(hutils)
library(magrittr)
library(data.table)
```

```{r requireGrattanCharts}
if (!requireNamespace("grattanCharts", quietly = TRUE) &&
    !requireNamespace("hutilscpp", quietly = TRUE)) {
  remotes::install_github("hughparsonage/hutilscpp", 
                          quietly = TRUE, 
                          quick = TRUE,
                          upgrade = FALSE)
  remotes::install_github("hughparsonage/grattanCharts",
                          quietly = TRUE,
                          quick = TRUE, 
                          upgrade = FALSE)
}
library(grattanCharts)
templib <- tempfile()
hutils::provide.dir(templib)
```

```{r loadGrattan}
library(grattan)
```

```{r clarify-namespace}
ntile <- function(x, n) {
  if (requireNamespace("dplyr", quietly = TRUE)) {
    dplyr::ntile(x, n)
  } else {
    grattan::weighted_ntile(x, n = n)
  }
}
coalesce <- hutils::coalesce
```

We also load the `taxstats` package. 
The other packages are private as the ATO has suppressed the information from the public: unfortunately, only approved institutions can use this data sets.

```{r loadTaxstats}
library(taxstats)
```

```{r sample_file_1415}
sample_file_1415 <-
  if (requireNamespace("SampleFile1415", quietly = TRUE)) {
    SampleFile1415::sample_file_1415
  } else {
    taxstats::sample_file_1415_synth
  }
```

```{r sample_file_1516}
sample_file_1516 <- 
  if (file.exists("~/ozTaxData/data-raw/2016_sample_file.csv")) {
    fread("~/ozTaxData/data-raw/2016_sample_file.csv", logical01 = FALSE)
  } else if (requireNamespace("taxstats", quietly = TRUE)) {
    taxstats1516::sample_file_1516_synth
  } else {
    project(sample_file_1415, h = 1L)
  }
```

```{r sample_files_all}
if (file.exists(sample_files_all.fst <- "budget-2018_cache/sample_files_all.fst") &&
    cache) {
  sample_files_all <- read_fst(sample_files_all.fst, as.data.table = TRUE)    
} else {
  provide.dir("budget-2018_cache")
  sample_files_all <-
    rbindlist(lapply(list(`2003-04` = sample_file_0304, 
                          `2004-05` = sample_file_0405,
                          `2005-06` = sample_file_0506, 
                          `2006-07` = sample_file_0607,
                          `2007-08` = sample_file_0708, 
                          `2008-09` = sample_file_0809,
                          `2009-10` = sample_file_0910, 
                          `2010-11` = sample_file_1011,
                          `2011-12` = sample_file_1112, 
                          `2012-13` = sample_file_1213,
                          `2013-14` = sample_file_1314,
                          `2014-15` = sample_file_1415,
                          `2015-16` = sample_file_1516), 
                     data.table::as.data.table),
              use.names = TRUE,
              fill = TRUE, 
              idcol = "fy.year")
  sample_files_all[, WEIGHT := hutils::if_else(fy.year > '2010-11', 50L, 100L)]
  sample_files_all[is.na(age_range), age_range := Birth_year]
  sample_files_all[is.na(Othr_pnsn_amt), Othr_pnsn_amt := 0L]
  sample_files_all[is.na(Med_Exp_TO_amt), Med_Exp_TO_amt := 0L]
  sample_files_all[is.na(Spouse_adjusted_taxable_inc), Spouse_adjusted_taxable_inc := 0L]
  age_range_decoder <- as.data.table(age_range_decoder)
  
  sample_files_all %>%
    .[, tax := income_tax(Taxable_Income, fy.year = .BY[[1L]], .dots.ATO = .SD), keyby = "fy.year"] %>%
    .[, avg_tax_rate := coalesce(tax / Taxable_Income, 0)] %>%
    .[, Taxable_Income_percentile := ntile(Taxable_Income, 100), keyby = "fy.year"]
  write_fst(sample_files_all, sample_files_all.fst)
}
```


```{r revenue_foregone}
revenue_foregone <- function(dt, revenue_positive = TRUE, digits = NULL) {
  out <- dt[, sum((as.integer(new_tax) - baseline_tax) * WEIGHT)]
  class(out) <- "revenue_foregone"
  setattr(out, "digits", digits)
  out
}

.revenue_foregone <- function(dt, revenue_positive = TRUE, digits = NULL) {
  out <- dt[, sum((as.integer(new_tax) - baseline_tax) * WEIGHT)]
  class(out) <- "revenue_foregone"
  setattr(out, "digits", digits)
  
  if (is_knitting()) {
    return(print.revenue_foregone(out))
  }
  out
}

print.revenue_foregone <- function(x, ...) {
  if (x < 0) {
    pre <- paste0("\u2212", if (is_knitting()) "\\$" else "$")
    x <- -x
  } else {
    pre <- "$"
  }
  d <- function(default) {
    if (is.null(attr(x, "digits"))) {
      default
    } else {
      attr(x, "digits")
    }
  }
  if (x > 10e9) {
    res <- paste0(pre, prettyNum(round(x / 1e9, d(0)), big.mark = ","), " billion")
  } else if (x > 1e9) {
    res <- paste0(pre, prettyNum(round(x / 1e9, d(1)), big.mark = ","), " billion")
  } else {
    res <- paste0(pre, prettyNum(round(x / 1e6, d(0)), big.mark = ","), " million")
  }
  print(res)
}
```

```{r get_near_term}
#' @details 700ms vs 57ms
get_near_term <- function(fy_year = c("2016-17", "2017-18", "2018-19")) {
  fy_year <- match.arg(fy_year)
  h <- as.integer(fy2yr(fy_year) - 2016L)
  syyyy <- paste0(substr(fy_year, 3, 4), substr(fy_year, 6, 7))
  if (file.exists(syyyy.fst <- sprintf("budget-2018_cache/%s.fst", syyyy)) && cache) {
    s <- read_fst(syyyy.fst, as.data.table = TRUE)
  } else {
    s <- 
      if (file.exists("~/ozTaxData/data-raw/2016_sample_file.csv")) {
        sample_file_1516 <- fread("~/ozTaxData/data-raw/2016_sample_file.csv")
        project(sample_file_1516, h = h , fy.year.of.sample.file = "2015-16")
      } else {
        project(sample_file_1415_synth, h = h + 1L, fy.year.of.sample.file = "2014-15")
      }
    s <- model_income_tax(s, "2017-18")
    s[, Taxable_Income_percentile := ntile(Taxable_Income, 100)]
    write_fst(s, syyyy.fst)
  }
}
```

```{r s1617}
s1617 <- get_near_term("2016-17")
```

```{r s1718}
s1718 <- get_near_term("2017-18")
```


```{r s1819}
s1819 <- get_near_term("2018-19")
```

```{r unique_fy_year}
# Used throughout: takes 0.25s of each query, improves consistency
unique_fy_year <- yr2fy(2019:2028)
```

These tables come from the Budget papers and will be passed to `project` so that the uprating can be set with fixed values. (By default `project` forecasts the series using the `forecast` package.)
```{r wage_forecasts}
wage_forecasts <- 
  data.table(fy_year = yr2fy(2018:2028),
             r = c(2.25, 2.75, 3.25, 3.5, 3.5, rep(3.5, 6)) / 100)
```

```{r lf_forecasts}
lf_forecasts <- 
  data.table(fy_year = yr2fy(2018:2028),
             r = c(2.75, 1.50, 1.50, 1.50, 1.25, rep(1.25, 6)) / 100)
```

These are functions of years from 2015-16 that return the tax rates and tax thresholds that the Government has proposed in the Budget. They are used so that the out years can be modelled conveniently as a function of the year only.

```{r ordinary_tax_rates}
ordinary_tax_rates <- function(fy_year) {
  if (fy_year < "2024-25") {
    c(0, 0.19, 0.325, 0.37, 0.45)
  } else {
    c(0, 0.19, 0.325, 0.45)  
  }
}
```

```{r ordinary_tax_thresholds}
ordinary_tax_thresholds <- function(fy_year) {
  if (fy_year < "2022-23") {
    c(0, 18200, 37e3, 90e3, 180e3)
  } else if (fy_year < "2024-25") {
    c(0, 18200, 45e3, 120e3, 180e3)
  } else {
    c(0, 18200, 45e3, 200e3)
  }
}
```

These functions increase the thresholds for the Medicare levy for low-income earners. 
Technically such measures have to be approved each financial year, but are as a matter of a routine.

```{r do_medicare_levy}
#' @param x2018 A length-one for the 2018-19 number.
#' @param fy The financial year
.do_medicare_levy <- function(x2018, fy) {
  stopifnot(length(fy) == 1L, is.fy(fy))
  if (fy == "2018-19") {
    return(x2018)
  } else {
    return(round(cpi_inflator(x2018, from_fy = "2017-18", to_fy = fy), -1))
  }
}

medicare_levy_lower_threshold <- function(fy) {
  .do_medicare_levy(21980, fy)
}

medicare_levy_lower_sapto_threshold <- function(fy) {
  .do_medicare_levy(34758, fy)
}

medicare_levy_lower_family_threshold <- function(fy) {
  .do_medicare_levy(48385, fy)
}

medicare_levy_lower_family_sapto_threshold <- function(fy) {
  .do_medicare_levy(48385, fy)
}

medicare_levy_lower_up_for_each_child <- function(fy) {
  .do_medicare_levy(3406, fy)
}

.project_to <- function(h, use.Treasury) {
  project(sample_file_1516,
          h = h,
          fy.year.of.sample.file = "2015-16",
          wage.series = if (use.Treasury) wage_forecasts,
          lf.series = if (use.Treasury) lf_forecasts) %>%
    setkey(Taxable_Income)
}
```

```{r project_useTreasurys, cache=cache}
.project_useTreasurys <- lapply(1:12, .project_to, use.Treasury = TRUE)
```

```{r .project_useGrattans, cache=cache}
.project_useGrattans <- lapply(1:12, .project_to, use.Treasury = FALSE)
```

```{r s2425_Treasury}
# && cache generally because the filename must be known if cache = FALSE
if (file.exists(s2425_Treasury.fst <- "budget-2018_cache/s2425_Treasury.fst") && cache) {
  s2425_Treasury <- read_fst(s2425_Treasury.fst, 
                             as.data.table = TRUE)
} else {
  s2425_Treasury <- .project_useTreasurys[[2025L - 2016L]]
  write_fst(s2425_Treasury, s2425_Treasury.fst)
}
```

```{r s2728_Treasury}
if (file.exists(s2728_Treasury.fst <- "budget-2018_cache/s2728_Treasury.fst") && cache) {
  s2728_Treasury <- read_fst(s2728_Treasury.fst, 
                             as.data.table = TRUE)
} else {
  s2728_Treasury <- .project_useTreasurys[[2028L - 2016L]]
  write_fst(s2728_Treasury, s2728_Treasury.fst)
}
```

```{r wage_r80}
wage_r80 <- 
  data.table(fy_year = yr2fy(c(2017:2028)),
             i = wage_inflator(from_fy = "2015-16",
                               to_fy = yr2fy(c(2017:2028)),
                               forecast.level = 80,
                               forecast.series = "upper")) %>%
  .[, r := i / shift(i) - 1] %>%
  .[!is.na(r), .(fy_year, r)]
```

```{r wage_r20}
wage_r20 <- 
  data.table(fy_year = yr2fy(c(2017:2028)),
             i = wage_inflator(from_fy = "2015-16",
                               to_fy = yr2fy(c(2017:2028)),
                               forecast.level = 80,
                               forecast.series = "lower")) %>%
  .[, r := i / shift(i) - 1] %>%
  .[!is.na(r), .(fy_year, r)]
```

```{r .project_useGrattans80, cache=cache}
.project_useGrattans80 <- lapply(1:12, function(h) {
  project(sample_file_1516, h = h, wage.series = wage_r80)
})
```

```{r .project_useGrattans20, cache=cache}
.project_useGrattans20 <- lapply(1:12, function(h) {
  project(sample_file_1516, h = h, wage.series = wage_r20)
})
```

```{r .project_useGrattans2.75, cache=TRUE}
.project_useGrattans2.75 <- lapply(1:12, function(h) {
  project(sample_file_1516, h = h, wage.series = 0.0275)
})
```


```{r model_Budgets}
#' @param level Prediction interval level.
#' @param wage.r A string like "2.75\%", the wage growth as a percentage.
model_Budgets <- function(fy_year, 
                          use.Treasury = TRUE,
                          .debug = FALSE,
                          level = NULL, 
                          wage.r = NULL) { 
  h <- as.integer(fy2yr(fy_year) - 2016L)
  s1920 <- NULL
  if (use.Treasury) {
    if (missing(level) && missing(wage.r)) {
      s1920 <- .project_useTreasurys[[h]]
    } else {
      stop("`use.Treasury = TRUE` yet `level` or `wage.r` are supplied.")
    }
  } else {
    if (is.null(level)) {
      if (is.null(wage.r)) {
        s1920 <- .project_useGrattans[[h]]
      } else {
        if (!is.character(wage.r) || length(wage.r) != 1) {
          stop("`wage.r` must be a string.")
        } 
        switch(wage.r, 
               "2.75%" = {
                 s1920 <- .project_useGrattans2.75[[h]]
               }, 
               stop("`wage.r = ", wage.r, "` not supported."))
      }
    } else {
      if (level == 20) {
        s1920 <- .project_useGrattans20[[h]]
      } else if (level == 80) {
        s1920 <- .project_useGrattans80[[h]]
      } else {
        stop("Level not supported.")
      }
    }
  }
  model_income_tax <- function(...,
                               lamington = FALSE,
                               lito_202223 = FALSE, 
                               watr = FALSE) {
    grattan::model_income_tax(
      sample_file = s1920, 
      baseline_fy = "2017-18",
      medicare_levy_lower_threshold = medicare_levy_lower_threshold(fy_year),
      medicare_levy_lower_sapto_threshold = medicare_levy_lower_sapto_threshold(fy_year),
      medicare_levy_lower_family_threshold = medicare_levy_lower_family_threshold(fy_year),
      medicare_levy_lower_family_sapto_threshold = medicare_levy_lower_family_sapto_threshold(fy_year),
      medicare_levy_lower_up_for_each_child = medicare_levy_lower_up_for_each_child(fy_year),
      warn_upper_thresholds = FALSE,
      Budget2018_lamington = lamington,
      Budget2018_lito_202223 = lito_202223,
      Budget2018_watr = watr,
      ...) %>%
      .[, .(Ind, age_range, Total_PP_BE_amt, Total_NPP_BE_amt, Taxable_Income, new_tax, baseline_tax, WEIGHT)] %>%
      setkey(Taxable_Income) %>%
      .[, new_tax := as.integer(new_tax)] %>%
      .[, delta := new_tax - baseline_tax] %>%
      
      .[]
  }
  
  is_lamington <- fy_year %in% c("2018-19", "2019-20", "2020-21", "2021-22")
  
  list(
    Budget2018_baseline = model_income_tax(),
    Baseline_brackets_cpi = model_income_tax(ordinary_tax_thresholds = cpi_inflator(ordinary_tax_thresholds(1),
                                                                                               from_fy = "2017-18",
                                                                                               to_fy = fy_year)),
    Budget2018_just_rates = model_income_tax(ordinary_tax_rates =  ordinary_tax_rates(fy_year),
                                             ordinary_tax_thresholds = ordinary_tax_thresholds(fy_year),
                                             lito_202223 = FALSE,
                                             lamington = FALSE),
    Budget2018_lamington_et_LITO = model_income_tax(lito_202223 = fy_year >= "2022-23",
                                                      lamington = is_lamington),
    Budget2018 = model_income_tax(ordinary_tax_rates = ordinary_tax_rates(fy_year),
                                  ordinary_tax_thresholds = ordinary_tax_thresholds(fy_year),
                                  lito_202223 = fy_year >= "2022-23",
                                  lamington = is_lamington),
    Budget2018_Step1and2 = model_income_tax(ordinary_tax_rates = ordinary_tax_rates(pmin(fy_year, "2022-23")), 
                                            ordinary_tax_thresholds = ordinary_tax_thresholds(pmin(fy_year, "2022-23")),
                                            lito_202223 = fy_year >= "2022-23", 
                                            lamington = is_lamington),
    ALP2018 = model_income_tax(ordinary_tax_rates = ordinary_tax_rates(pmin(fy_year, "2022-23")), 
                               ordinary_tax_thresholds = ordinary_tax_thresholds(pmin(fy_year, "2022-23")),
                               lamington = FALSE,
                               watr = TRUE))
}
```

```{r ntilers}
.ntile <- function(x, n) {
  if (is.unsorted(x)) {
    stop("`x` must be sorted.")
  }
  as.integer(floor(n * (seq_along(x) - 1)/length(x) + 1))
}
.ntile2 <- function(x, n, N = length(x)) {
  if (is.unsorted(x)) {
    stop("`x` must be sorted.")
  }
  as.integer(floor(n * (seq_len(N) - 1)/N + 1))
}

```

```{r percentile2quintile}
percentile2quintile <- function(p) {
  {{p - 1L} %/% 20L} + 1L
}
stopifnot(identical(ntile(1:100, 5), percentile2quintile(1:100)))
x <- rnorm(1009)
stopifnot(identical(ntile(x, 5), percentile2quintile(ntile(x, 100))))
rm(x)
```

```{r rowname2column}
rowname2column <- function(df, newcol = "id") {
  if (is.data.table(df)) {
    warning("`df` is a data.table. No rownames to provide.")
    return(df)
  } else {
    rn <- rownames(as.matrix(df))
    out <- as.data.table(as.matrix(df))
    cbind(data.table(id = rn), out)
  }
}
```

```{r bind_Budget2018_models}
bind_Budget2018_models <- function(chunk, .cache = cache, ...) {
  if (is_knitting()) {
    current_chunk <- opts_current$get(name = "label")
    if (!identical(chunk, current_chunk)) {
      stop("`chunk = ", chunk, "`, yet\n", 
           "current chunk: ", current_chunk, ".")
    }
  }
  
  if (file.exists(x.fst <- sprintf("budget-2018_cache/%s.fst", chunk)) && .cache) {
    read_fst(x.fst, as.data.table = TRUE)
  } else {
    Budget_1922 <- lapply(unique_fy_year, model_Budgets, ...)
    names(Budget_1922) <- unique_fy_year
    
    if (is_knitting()) {
      revenue_fy_year <- 
        sapply(Budget_1922, sapply, revenue_foregone, USE.NAMES = TRUE) %>%
        divide_by(1e9)
      revenue_by_id <-
        revenue_fy_year %>%
        rowSums
      
      revenue_fy_year <- rowname2column(revenue_fy_year)
      revenue_by_id <- rowname2column(revenue_by_id)
      setnames(revenue_by_id, "V1", "Revenue/$bn")
      
      file_suffix <- sub("bound_models_?", "", current_chunk)
      if (nzchar(file_suffix)) {
        # i.e. -- designates deviation from budget
        file_suffix <- paste0("--", file_suffix)
      }
      fwrite(revenue_fy_year, sprintf("revenue-by-fy_year-id%s.csv", file_suffix))
      fwrite(revenue_by_id, sprintf("revenue-by-id%s.csv", file_suffix))
    }
    
    a <- lapply(Budget_1922, rbindlist, use.names = TRUE, fill = TRUE, idcol = "id")
    b <- rbindlist(a, use.names = TRUE, fill = TRUE, idcol = "fy_year")
    setkey(b, fy_year, id, Taxable_Income)
    b[, Taxable_Income_percentile := .ntile(Taxable_Income, 100), 
      keyby = c("fy_year", "id")]
    b[, Quintile := percentile2quintile(Taxable_Income_percentile)]
    setkey(b, fy_year, id, Taxable_Income)
    write_fst(b, x.fst)
    b[]
  } 
}

```

```{r bound_models, cache=FALSE}
bound_models <- bind_Budget2018_models("bound_models")
if (!cache) {
  bound_models[id %in% c("Budget2018", "Budget2018_Step1and2", "Budget2018_baseline"),
               .SD,
               .SDcols = c("id",
                           "fy_year",
                           "delta",
                           "WEIGHT",
                           "Taxable_Income", 
                           "new_tax", 
                           "baseline_tax")] %>%
    fst::write_fst(path = "~/Budget-2018-Senate-submission/data/bound-models.fst", 
                   compress = 100)
}
```


```{r bound_models_Grattan}
bound_models_Grattan <- bind_Budget2018_models("bound_models_Grattan", use.Treasury = FALSE)
```


```{r bound_models_Grattan80}
bound_models_Grattan80 <- bind_Budget2018_models("bound_models_Grattan80", 
                                                 use.Treasury = FALSE, 
                                                 level = 80)
```

```{r bound_models_Grattan20}
bound_models_Grattan20 <- bind_Budget2018_models("bound_models_Grattan20", 
                                                 use.Treasury = FALSE, 
                                                 level = 20)
```

```{r bound_models_Grattan2.75}
bound_models_Grattan2.75 <-
  bind_Budget2018_models("bound_models_Grattan2.75", 
                         use.Treasury = FALSE, 
                         wage.r = "2.75%")
```

### Costings 2018-19 to 2027-28 (Govt growth assumptions)

```{r Budget-summaries}
kable(fread("revenue-by-fy_year-id.csv"))
```

### Costings 2018-19 to 2027-28 (Grattan default forecasts)

```{r Budget-summaries-Grattan}
kable(fread("revenue-by-fy_year-id--Grattan.csv"))
```

**80\% wage optimistic**

```{r Budget-summaries-Grattan-80}
kable(fread("revenue-by-fy_year-id--Grattan80.csv"))
```

**20\% wage pessimistic**

```{r Budget-summaries-Grattan-20}
kable(fread("revenue-by-fy_year-id--Grattan20.csv"))

```

```{r avg_individual_impact_by_Quintile_fy}
avg_individual_impact_by_Quintile_fy <- 
  bound_models %>%
  .[, Quintile := .ntile(Taxable_Income, 5),
    keyby = .(fy_year, id)] %>%
   .[, Quintile := factor(Quintile, levels = 1:5)] %>%
  .[, .(avg_delta = mean(delta),
        max_income = max(Taxable_Income),
        min_income = min(Taxable_Income),
        avg_income = mean(Taxable_Income + 0)),
    keyby = .(id, fy_year, Quintile)] %>%
  .[, "Financial year ending" := fy2yr(fy_year)] %>%
  .[, avg_delta := round(avg_delta, 2)] %T>%
  fwrite("avg_individual_impact_by_Quintile_fy.csv") %>%
  .[] 

avg_individual_impact_by_Quintile_fy %>%
  grplot(aes(x = `Financial year ending`,
             y = avg_delta,
             fill = Quintile),
         reverse = TRUE) +
  geom_col(position = "dodge") + 
  ggtitle("Average individual impact") +
  scale_y_continuous(labels = grattan_dollar) + 
  guides(fill = guide_legend(reverse = FALSE)) +
  theme(axis.line.x = element_line(size = 0.5),
        legend.position = "right")
```

```{r avg_individual_impact_by_Quintile_fy__2.75}
avg_individual_impact_by_Quintile_fy__2.75 <- 
  bound_models_Grattan2.75 %>%
  .[.(unique_fy_year, "Budget2018"),
    .(avg_delta = mean(delta),
      max_income = max(Taxable_Income),
      min_income = min(Taxable_Income),
      avg_income = mean(Taxable_Income + 0)),
    keyby = .(fy_year, id, Quintile)] %>%
  .[, "Financial year ending" := fy2yr(fy_year)] %>%
  .[, avg_delta := round(avg_delta, 2)] %T>%
  fwrite("avg_individual_impact_by_Quintile_fy-2p75.csv") %>%
  .[] 

avg_individual_impact_by_Quintile_fy__2.75 %>%
  .[, .(`Financial year ending`,
        avg_delta,
        Quintile = factor(Quintile))] %>%
  grplot(aes(x = `Financial year ending`,
             y = avg_delta,
             fill = Quintile),
         reverse = TRUE) +
  geom_col(position = "dodge") + 
  ggtitle("Average individual impact (2.75% wages)") +
  scale_y_continuous(labels = grattan_dollar) + 
  guides(fill = guide_legend(reverse = FALSE)) +
  theme(axis.line.x = element_line(size = 0.5),
        legend.position = "right")
```


```{r Brackets}
Brackets <- 
  bound_models[.(unique_fy_year, "Budget2018"), 
               .(Breaks = c(0, 37e3, 41e3, 87e3, 90e3, 120e3, 180e3, 200e3)),
               keyby = c("fy_year", "id")]%>%
  .[, Taxable_Income := as.integer(Breaks)] %>%
  setkey(fy_year, id, Taxable_Income)
```

```{r avg_individual_impact_by_Bracket_fy}
avg_individual_impact_by_Bracket_fy <-
  # Match every taxable income with the correct bracket
  Brackets[setkey(bound_models[.(unique_fy_year, "Budget2018"),
                               .(fy_year, id, Taxable_Income, delta)],
                  fy_year, id, Taxable_Income),
           roll=TRUE,
           nomatch=0L] %>%
  
  .[, .(avg_delta = mean(delta)),
    keyby = .(fy_year, Breaks)] %>%
  .[, "Financial year ending" := fy2yr(fy_year)] 

avg_individual_impact_by_Bracket_fy %>%
  .[, avg_delta := round(avg_delta, 2)] %>%
  .[] %>%
  .[, "Income bracket" := factor(Breaks,
                                 levels = unique(Breaks),
                                 labels = grattan_dollar(unique(Breaks)),
                                 ordered = TRUE)] %T>%
  fwrite("Total-revenue-vs-fy-by-income-bracket.csv") %>%
  grplot(aes(x = `Financial year ending`, y = avg_delta, fill = `Income bracket`),
         reverse = TRUE) +
  geom_col() + 
  ggtitle("Average individual impact") +
  scale_y_continuous(labels = grattan_dollar) + 
  guides(fill = guide_legend(reverse = TRUE)) +
  theme(legend.position = "right")
```

```{r Total-revenue-vs-fy-by-incomes-above}
Brackets[setkey(bound_models[.(unique_fy_year, "Budget2018"),
                             .(fy_year, id, Taxable_Income,
                               total_delta = delta * WEIGHT / 1e9)],
                fy_year, id, Taxable_Income),
           roll=TRUE,
           nomatch=0L] %>%
  .[, .(total_delta = sum(total_delta)),
    keyby = .(fy_year, Breaks)] %>%
  .[, "Financial year ending" := fy2yr(fy_year)] %>%
  .[, total_delta := round(total_delta, 2)] %>%
  .[order(-Breaks)] %>%
  .[, "Incomes above" := factor(Breaks,
                                levels = unique(Breaks),
                                labels = grattan_dollar(unique(Breaks)),
                                ordered = TRUE)] %T>%
  fwrite("Total-revenue-vs-fy-by-incomes-above.csv") %>%
  grplot(aes(x = `Financial year ending`, y = total_delta, fill = `Incomes above`)) +
  geom_col() + 
  ggtitle("Total revenue") +
  scale_y_continuous(labels = grattan_dollar) + 
  guides(fill = guide_legend(reverse = TRUE)) +
  theme(legend.position = "right")
```

```{r cost_in_202728}
cost_in_202728 <- 
  revenue_foregone(bound_models[.("2027-28", "Budget2018")], FALSE, digits = 0)
cost_in_202728_top20 <- 
  bound_models[.("2027-28", "Budget2018")] %>%
  .[ntile(Taxable_Income, 100) >= 80] %>%
  revenue_foregone(revenue_positive = FALSE, digits = 0)
```

```{r minIncome_by_decile}
minIncome_by_decile <- 
  s1718[, .(minIncome = min(Taxable_Income)), keyby = .(Decile = ntile(Taxable_Income, 10))] %>%
  .[, minIncome := as.integer(round(minIncome, -3))] %>%
  .[]
```

```{r avg_tax_rates_by_percentile_facet_fy}
avg_tax_rates_by_percentile_facet_fy <-
{
  rbindlist(
    list(
      "Budget2018" = {
        bound_models %>%
          .[.(unique_fy_year, "Budget2018"),
            .(avg_tax_rate = mean(coalesce(new_tax / Taxable_Income, 0)),
              avg_tax_bill = mean(new_tax),
              total_tax = sum(new_tax * WEIGHT / 1e9),
              min_income = min(Taxable_Income),
              max_income = max(Taxable_Income),
              avg_income = mean(Taxable_Income + 0)),
            keyby = .(fy_year, Taxable_Income_percentile)] %>%
          .[, facet := "Budget 2018"]
      },
      "Grattan 20%" = {
        bound_models_Grattan20 %>%
          .[.(unique_fy_year, "Budget2018"),
            .(avg_tax_rate = mean(coalesce(new_tax / Taxable_Income, 0)),
              avg_tax_bill = mean(new_tax),
              total_tax = sum(new_tax * WEIGHT / 1e9),
              min_income = min(Taxable_Income),
              max_income = max(Taxable_Income),
              avg_income = mean(Taxable_Income + 0)),
            keyby = .(fy_year, Taxable_Income_percentile)] %>%
          .[, facet := "Budget 2018 (20% wage forecast)"]
      },
      "Grattan 80%" = {
        bound_models_Grattan80 %>%
          .[.(unique_fy_year, "Budget2018"),
            .(avg_tax_rate = mean(coalesce(new_tax / Taxable_Income, 0)),
              avg_tax_bill = mean(new_tax),
              total_tax = sum(new_tax * WEIGHT / 1e9),
              min_income = min(Taxable_Income),
              max_income = max(Taxable_Income),
              avg_income = mean(Taxable_Income + 0)),
            keyby = .(fy_year, Taxable_Income_percentile)] %>%
          .[, facet := "Budget 2018 (80% wage forecast)"]
      },
      
      "Baseline" = {
        bound_models[.(unique_fy_year, "Budget2018_baseline"),
          .(avg_tax_rate = mean(coalesce(new_tax / Taxable_Income, 0)),
            avg_tax_bill = mean(new_tax),
            total_tax = sum(new_tax * WEIGHT / 1e9),
            min_income = min(Taxable_Income),
            max_income = max(Taxable_Income),
            avg_income = mean(Taxable_Income + 0)),
          keyby = .(fy_year, Taxable_Income_percentile)] %>%
          .[, facet := "Baseline"] %>%
          .[]
      },
      "Current" = {
        s1718[,
              .(avg_tax_rate = mean(coalesce(new_tax / Taxable_Income, 0)),
                avg_tax_bill = mean(new_tax),
                min_income = min(Taxable_Income),
                max_income = max(Taxable_Income),
                total_tax = sum(new_tax * WEIGHT / 1e9),
                avg_income = mean(Taxable_Income + 0)), 
              keyby = .(Taxable_Income_percentile)] %>%
          .[, facet := "2017-18"] %>%
          .[, fy_year :=  "2017-18"]
      }),
      use.names = TRUE, fill = TRUE, 
    idcol = "id")
  } %>% 
  .[, "Financial year ending" := fy2yr(fy_year)] %>%
  setkey(fy_year, id, Taxable_Income_percentile) %>%
  .[, avg_tax_rate := round(avg_tax_rate, 3)] %>%
  .[, total_tax := round(total_tax, 3)] %>%
  setnames("total_tax", "total_tax_bn") %T>%
  fwrite(file = "avg_tax_rates-by-facet-percentile.csv") %>%
  .[]
```

```{r avg_tax_rates_by_percentile_Budget_202728_vs_201718}
avg_tax_rates_by_percentile_facet_fy %>%
  .[.(c("2017-18", "2027-28"))] %>%
  .[facet %in% c("Baseline", "Budget 2018", "2017-18")] %T>%
  {
    dot <- .
    dot[, .(facet, fy_year, Taxable_Income_percentile, avg_tax_rate)] %>%
      dcast.data.table(Taxable_Income_percentile ~ facet + fy_year,
                       value.var = "avg_tax_rate") %>%
      melt.data.table(id.vars = c("Taxable_Income_percentile", "2017-18_2017-18")) %>%
      setnames("2017-18_2017-18", "T201718") %>%
      .[, delta := value - T201718] %>%
      fwrite("change-in-tax-rate-vs-201718-by-percentile.csv")
  } %>%
  .[, Decile := ntile(Taxable_Income_percentile, n = 10), by = "facet"] %T>%
  {
    dot <- .
    dot %>%
      .[, .(total_tax_bn = sum(total_tax_bn)), keyby = .(facet, Decile)] %>%
      .[, "% tax paid" := 100 * total_tax_bn / sum(total_tax_bn), keyby = "facet"] %>%
      .[, lapply(.SD, signif, 3), keyby = .(facet, Decile)] %>%
      fwrite("prop-tax-paid-by-facet-decile.csv")
  } %>%
  grplot(aes(x = Taxable_Income_percentile, y = avg_tax_rate, color = facet)) + 
  geom_line() + 
  xlab("Taxable income percentile") +
  scale_y_continuous(labels = percent) +
  theme(legend.position = c(0, 1),
        axis.line.x = element_line(size = 0.5),
        legend.title = element_blank(),
        legend.justification = c(0, 1))
```

```{r avg_tax_rates_by_percentile_Budget_202728_vs_201718_with_PI}
avg_tax_rates_by_percentile_facet_fy %>%
  .[.(c("2017-18", "2027-28"))] %>%
  .[facet %in% c("Baseline", "Budget 2018", "2017-18", 
                 "Budget 2018 (20% wage forecast)", 
                 "Budget 2018 (80% wage forecast)")] %>%
  .[avg_tax_rate > 0] %>%
  .[, labeli := which.max(avg_tax_rate > 0.15), keyby = "facet"] %>%
  .[, i := seq_len(.N), keyby = "facet"] %>%
  .[labeli == i, label := as.character(facet)] %>%
  .[, label_color := "black"] %>%
  .[facet == "2017-18", label_color := "white"] %>% 
  .[, facet := factor(facet, 
                      levels = c("Baseline",
                                 "Budget 2018",
                                 "Budget 2018 (80% wage forecast)", 
                                 "Budget 2018 (20% wage forecast)",
                                 "2017-18"), 
                      ordered = TRUE)
    ] %>%
  
  grplot(aes(x = Taxable_Income_percentile,
             y = avg_tax_rate,
             color = facet)) + 
  geom_line() + 
  # geom_label_repel(data = dot, 
  #                  aes(label = label,
  #                      fill = facet),
  #                  color = "black",
  #                  force = 2,
  #                  na.rm = TRUE) +
  xlab("Taxable income percentile") +
  scale_y_continuous(labels = percent, expand = c(0, 0)) +
  theme(legend.position = c(0.95, 0.05),
        axis.line.x = element_line(size = 0.5),
        legend.title = element_blank(),
        legend.justification = c(1, 0))

```

```{r decile2income}
decile2income <- function(d) {
  d <- as.integer(d)
  grattan_dollar(minIncome_by_decile[.(d)][["minIncome"]])
}
```

```{r texNumD}
texNumD <- function(x) texNum(x, dollar = TRUE)
```


New Grattan Institute analysis highlights that most of the revenue
reductions from the Turnbull Government's full Personal Income Tax Plan
are the result of lower taxes on high-income earners. Once the
three-stage plan -- including removing the 37c bracket -- is complete,
**`r texNumD(abs(cost_in_202728_top20))`** of the annual **`r texNumD(abs(cost_in_202728))` cost** of the plan will
result from collecting less tax from the top 20% of income earners, who
currently have a taxable income of `r decile2income(8)` or more.

The PIT plan will do little to unwind bracket creep's gradual reduction
of the progressivity of the tax system. Even with the PIT plan, average
tax rates are forecast to be higher for all taxpayers in 2027-28 --
except for very high-income earners who are effectively shielded from
bracket creep by the plan. A taxpayer who earns 
`r decile2income(10)` 
today (more
than 90% of other taxpayers) will pay an average tax rate of 
`r avg_tax_rates_by_percentile_facet_fy[.("Budget2018", "2027-28", 90L)][['avg_tax_rate']] %>% grattan_percent` in
2027-28, unchanged from today. 
In contrast, average tax rates for
middle-income earners will continue to rise. The average tax rate for a
taxpayer who earns `r decile2income(4)`-a-year today (more than 30% of other
taxpayers) will increase 6 percentage points (from 
`r avg_tax_rates_by_percentile_facet_fy[.("Current", "2017-18", 40L)][['avg_tax_rate']] %>% grattan_percent`
to
`r avg_tax_rates_by_percentile_facet_fy[.("Budget2018", "2027-28", 40L)][['avg_tax_rate']] %>% grattan_percent`
). As a
result, the highest-income taxpayers will bear a lower share of the
total tax burden.

**Costing and distributional analysis of PIT plan **

The 2018-19 budget shows the annual cost of the PIT Plan until 2022. The
Treasurer has indicated the ten-year cost of the plan is \$140 billion.
Grattan's analysis shows the annual costs of the plan until 2028. The
Grattan costing takes into account all elements of the PIT plan.

Most of the revenue reductions until 2021-22 are a result of the Low and
Middle Income Tax Offset ("the Lamington"). But once the plan is fully
implemented in 2024-25, there are much bigger revenue reductions because
the top of the 32.5 cent bracket increases first to \$120,000 and then
to \$200,000 (removing the 37c bracket). In 2028, these bracket changes
account for `r texNumD(revenue_foregone(bound_models[.("2027-28", "Budget2018_just_rates")], FALSE))`
of the `r texNumD(revenue_foregone(bound_models[.("2027-28", "Budget2018")]))` in lower revenue.



Once fully implemented, most of the reduction in revenue under the PIT
is retained by the top 20% of income earners, with a taxable income of
\$87,000 or more. In 2028, the reduction in tax collected from this
group will account for **\$15 billion** of the \$25 billion cost of the
plan.


```{r Qfy2Cut}
# Quintile and financial year to tax cut
Qfy2Cut <- function(Quintile, fy) {
  q <- factor(as.integer(Quintile), levels = 1:5)
  stopifnot(haskey(avg_individual_impact_by_Quintile_fy), 
            identical(key(avg_individual_impact_by_Quintile_fy), 
                      c("id", "fy_year", "Quintile")), 
            length(fy) == 1L, 
            length(q) == 1L)
  ans <- -1*avg_individual_impact_by_Quintile_fy[.("Budget2018", fy, q), avg_delta]
  grattan_dollar(round(ans, -2))
}
```


By 2024-25, the income tax cuts are much larger for high-income earners,
both in absolute terms and as a proportion of income. Those in the top
20 per cent will get an average tax cut of `r Qfy2Cut(5, "2027-28")` a year, compared to
`r Qfy2Cut(2, "2027-28")` a year for someone in the second income quintile (`r decile2income(2)` -
`r decile2income(3)`).



**Impact of the PIT plan on tax system progressivity**

Australia's progressive tax system ensures that people with higher
incomes pay higher average rates of personal income tax. Without changes
to tax scales, bracket creep gradually increases average tax rates for
all taxpayers. Middle-income earners are affected most in terms of
higher average tax rates.

The government claims the PIT plan protects middle-income Australians
from bracket creep. Certainly the plan reduces average tax rates in
2027-28 for all taxpayers compared to what they would be if there were
no changes to rates or brackets over that period.

```{r avgTaxRate50}
avgTaxRate50 <- function(idd, fy) {
  stopifnot(identical(key(avg_tax_rates_by_percentile_facet_fy), 
                      c("fy_year", "id", "Taxable_Income_percentile")),
            length(idd) == 1L,
            length(fy) == 1L, 
            "avg_tax_rate" %in% names(avg_tax_rates_by_percentile_facet_fy))
  avg_tax_rates_by_percentile_facet_fy[.(fy, idd, 50L), avg_tax_rate]
}
```

But middle-income earners are not spared from bracket creep under the
PIT plan. The average tax rate for a taxpayer at the 50^th^ percentile
will still increase by 
`r round(100 * (avgTaxRate50("Budget2018", "2027-28") - avgTaxRate50("Current", "2017-18")))`
percentage points
(from 
`r percent(avgTaxRate50("Current", "2017-18"))`
to 
`r percent(avgTaxRate50("Budget2018", "2027-28"))`
)
compared to
2017-18. Without further changes, average tax rates will be higher for
most taxpayers.

The exception is the top 10% of income earners. Average tax rates for
those on the highest incomes are virtually unchanged under this plan.

Once fully implemented, the PIT plan doesn't change the progressivity of
the tax system much. Overall, those on high incomes will pay a similar
proportion of total tax revenues with or without the plan. But because
of bracket creep, high income earners will be paying a lower proportion
than today.

**Table 1: Share of personal income tax paid falls for highest income earners under PIT plan**

Share of total personal income tax paid by income decile (%)

```{r to_prop}
to_prop <- function(x) {
  if (is.double(x)) {
    grattan_percent(x / sum(x), .percent.suffix = "%", digits = 1)
  } else {
    x
  }
}
```

```{r provide-tax-s1718}
if ("tax" %notchin% names(s1718)) {
  if ("new_tax" %chin% names(s1718)) {
    s1718[, tax := new_tax + 0]
  } else {
    s1718[, tax := income_tax(Taxable_Income, "2017-18", .dots.ATO = .SD)]
  }
}
```

```{r share-total-pit-by-decile}
ShareTaxPaid_by_Decile_id <- 
  list("2017-18" = select_grep(s1718, "^(new_)?tax$", .and = "Taxable_Income"),
       "2027-28 baseline" = bound_models[.("2027-28", "Budget2018_baseline"), .(Taxable_Income, tax = new_tax)],
       "2027-28 budget" = bound_models[.("2027-28", "Budget2018_baseline"), .(Taxable_Income, tax = new_tax)]
  ) %>%
  rbindlist(use.names = TRUE,
            fill = TRUE,
            idcol = "id") %>%
  .[, Decile := ntile(Taxable_Income, 10), keyby = "id"] %>%
  .[, .(tot = sum(tax)), keyby = .(id, Decile)] %>%
  .[, share := tot / sum(tot), keyby = "id"]

ShareTaxPaid_by_Percentile_id <- 
  list("2017-18" = select_grep(s1718, "^(new_)?tax$", .and = "Taxable_Income"),
       "2027-28 baseline" = bound_models[.("2027-28", "Budget2018_baseline"), .(Taxable_Income, tax = new_tax)],
       "2027-28 budget" = bound_models[.("2027-28", "Budget2018_baseline"), .(Taxable_Income, tax = new_tax)]
  ) %>%
  rbindlist(use.names = TRUE,
            fill = TRUE,
            idcol = "id") %>%
  .[, Percentile := ntile(Taxable_Income, 100), keyby = "id"] %>%
  .[, .(tot = sum(tax)), keyby = .(id, Percentile)] %>%
  .[, share := tot / sum(tot), keyby = "id"]

rbindlist(
  list(ShareTaxPaid_by_Decile_id %>%
         .[Decile != 10L] %>%
         dcast(Decile ~ id, value.var = "share") %>%
         .[, Decile := as.character(Decile)], 
       ShareTaxPaid_by_Percentile_id %>%
         .[Percentile > 90L] %>%
         .[, .(share = sum(share)), 
           by = .(id, Decile = 10L * (Percentile %/% 10L))] %>%
         dcast(Decile ~ id, value.var = "share")),
  use.names = TRUE,
  fill = TRUE) %>%
  .[Decile %enotin% as.character(1:9), Decile := if_else(Decile == 100, "1%", "91-99 perc.")] %>%
  .[, lapply(.SD, round, 3), by = "Decile"] %T>%
  fwrite("share-of-tot-income-tax-by-decile-top1pc-budget-wage-growth.csv") %>%
  kable(align = "rrrr")
```

```{r share-total-pit-by-decile-275}
ShareTaxPaid_by_Decile_id <- 
  list("2017-18" = s1718[, .(Taxable_Income, tax)],
       "2027-28 baseline" = bound_models_Grattan2.75[.("2027-28", "Budget2018_baseline"), .(Taxable_Income, tax = new_tax)],
       "2027-28 budget" = bound_models_Grattan2.75[.("2027-28", "Budget2018"), .(Taxable_Income, tax = new_tax)]
  ) %>%
  rbindlist(use.names = TRUE,
            fill = TRUE,
            idcol = "id") %>%
  .[, Decile := ntile(Taxable_Income, 10), keyby = "id"] %>%
  .[, .(tot = sum(tax)), keyby = .(id, Decile)] %>%
  .[, share := tot / sum(tot), keyby = "id"]

ShareTaxPaid_by_Percentile_id <- 
  list("2017-18" = s1718[, .(Taxable_Income, tax)],
       "2027-28 baseline" = bound_models_Grattan2.75[.("2027-28", "Budget2018_baseline"), .(Taxable_Income, tax = new_tax)],
       "2027-28 budget" = bound_models_Grattan2.75[.("2027-28", "Budget2018"), .(Taxable_Income, tax = new_tax)]
  ) %>%
  rbindlist(use.names = TRUE,
            fill = TRUE,
            idcol = "id") %>%
  .[, Percentile := ntile(Taxable_Income, 100), keyby = "id"] %>%
  .[, .(tot = sum(tax)), keyby = .(id, Percentile)] %>%
  .[, share := tot / sum(tot), keyby = "id"]

rbindlist(
  list(ShareTaxPaid_by_Decile_id %>%
         .[Decile != 10L] %>%
         dcast(Decile ~ id, value.var = "share") %>%
         .[, Decile := as.character(Decile)], 
       ShareTaxPaid_by_Percentile_id %>%
         .[Percentile > 90L] %>%
         .[, .(share = sum(share)), 
           by = .(id, Decile = 10L * (Percentile %/% 10L))] %>%
         dcast(Decile ~ id, value.var = "share")),
  use.names = TRUE,
  fill = TRUE) %>%
  .[Decile %enotin% as.character(1:9), Decile := if_else(Decile == 100, "1%", "91-99 perc.")] %>%
  .[, lapply(.SD, round, 3), by = "Decile"] %T>%
  fwrite("share-of-tot-income-tax-by-decile-top1pc-2-75-wage-growth.csv") %>%
  kable(align = "rrrr")
```


```{r share-total-personal-income-tax-per-decile}
avg_tax_rates_by_percentile_facet_fy %>%
  .[, .(tot_tax = sum(total_tax_bn)),
    keyby = .(id, fy_year, Decile = ntile(Taxable_Income_percentile, 10))] %>%
  .[fy_year %in% c("2017-18", "2027-28")] %>%
  dcast.data.table(Decile ~ id + fy_year, value.var = "tot_tax") %>%
  .[, lapply(.SD, to_prop)] %T>%
  fwrite("share-total-personal-income-tax-per-decile.csv") %>%
  kable(align = "rrrr")
```
  

```{r scale01}
scale01 <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}
scale10 <- function(x) {
  1 - scale01(x)
}

```

```{r Grey}
Grey <- function(fy) {
  Alpha <- 0.5 * scale10(fy2yr(fy))
  out <- grey(rep_len(1, length(fy)))
  for (i in seq_along(fy)) {
    out[i] <- grey(0.7, alpha = Alpha[i])
  }
  out
}
```

```{r Average-tax-rates-relative-201718-vs-Taxable-income-percentile-by-FY}
sample_files_all %>%
  .[, .(avg_tax_rate = mean(avg_tax_rate)),
    keyby = .(fy.year, Taxable_Income_percentile)] %>%
  setnames("fy.year", "fy_year") %>%
  rbind(avg_tax_rates_by_percentile_facet_fy[CJ(unique(fy_year),
                                               c("Baseline", "Budget2018", "Current")),
                                             .SD, 
                                             .SDcols = c("id", names(.)),
                                             nomatch=0L],
        use.names = TRUE,
        fill = TRUE) %>%
  setkey(fy_year, Taxable_Income_percentile) %>%
  .[, z := fy_year %ein% "2017-18"] %>%
  .[, avg_tax_rate_rel := avg_tax_rate - median(avg_tax_rate[z]),
    keyby = .(Taxable_Income_percentile)] %>%
  .[, is_max_hist := and(fy_year < "2017-18",
                         avg_tax_rate_rel == max(avg_tax_rate_rel[fy_year < "2017-18"]))] %>%
  .[, is_min_hist := and(fy_year < "2017-18",
                         avg_tax_rate_rel == min(avg_tax_rate_rel[fy_year < "2017-18"]))] %T>%
  .[, stopifnot(Taxable_Income_percentile[is_max_hist] < 30L,
                fy_year[is_max_hist] == "2004-05",
                avg_tax_rate_rel[is_max_hist] %between% c(0.06, 0.07),
                
                Taxable_Income_percentile[is_min_hist] %between% c(45, 55),
                avg_tax_rate_rel[is_min_hist] %between% c(-0.05, -0.04),
                fy_year[is_min_hist] == "2009-10")] %>%

  .[, colour := if_else(is.na(id),
                        grey(0.5), 
                        if_else(id == "Baseline" & fy_year %in% c("2018-19", "2027-28"), 
                                if_else(fy_year == "2018-19", 
                                        gpal(6)[4],
                                        gpal(6)[5]),
                                if_else(fy_year == "2018-19", 
                                        gpal(6)[1],
                                        gpal(6)[2])))] %>%
  .[, alpha := if_else(is.na(id), 1.05 * scale01(fy2yr(fy_year)), 1)] %>%
  .[fy_year %in% c("2004-05", "2009-10"), c("alpha", "colour") := list(0.8, "black")] %>%
  .[implies(!is.na(id), fy_year %in% c("2018-19", "2027-28"))] %>%
  .[, size := 0.8] %>%
  .[fy_year %in% c("2004-05", "2009-10"), size := 1.1] %>%
  .[fy_year %in% c("2018-19", "2027-28"), size := 1.4] %>%
  .[Taxable_Income_percentile == 50L & !is.na(id),
    label := paste0(id, "\n", as.character(fy_year))] %>% 
  # .[Taxable_Income_percentile == 95L & !is.na(id), label := ""] %>%
  .[] %>%
  .[, group := paste0(fy_year, colour)] %>%
  .[, text := paste0(fy_year, " ", coalesce(id, ""), "\n",
                     formatC("Percentile: ", width = 24), Taxable_Income_percentile, "\n",
                     formatC("Avg. tax rate (17-18 = 0):", width = 24),
                     " ",
                     100 * round(avg_tax_rate_rel, 4))] %>%
  .[] %>%
  setnames("Taxable_Income_percentile", 
           "Taxable income percentile") %T>%
  fwrite("Average-tax-rates-relative-201718-vs-Taxable-income-percentile-by-FY.csv") %>%
  as.data.frame %>%
  # .[Over65==FALSE] %>%
  grplot(aes(x = `Taxable income percentile`,
             y = avg_tax_rate_rel,
             colour = colour,
             group = group)) +
  annotate("label",
           x = 20,
           y = 0.07, 
           hjust = 1,
           label.size = NA,
           label = "2004-05",
           fontface = "bold") +
  annotate("label",
           x = 45,
           y = -0.04,
           hjust = 1,
           label.size = NA,
           label = "2009-10",
           fontface = "bold") +
  scale_color_identity() +
  scale_size_identity() +
  scale_alpha_identity() +
  geom_line(aes(alpha = alpha, size = size)) +
  # geom_blank(aes(x = 105, y = 0)) +
  geom_label_repel(aes(label = label),
                   nudge_x = 2, force = 0.8,
                   na.rm = TRUE,
                   fontface = "bold",
                   label.size = NA) +
  scale_y_continuous(labels = percent) +
  ggtitle("Average tax rates relative to 2017-18") +
  theme(legend.position = "right")
```

```{r avg_tax_rate_by_percentile_fy_year_rel0304}
sample_files_all %>%
  .[, .(avg_tax_rate = mean(avg_tax_rate)), keyby = .(fy.year, Taxable_Income_percentile)] %>%
  setnames("fy.year", "fy_year") %>%
  rbind(avg_tax_rates_by_percentile_facet_fy[, .SD, .SDcols = c("id", names(.))],
        use.names = TRUE,
        fill = TRUE) %>%
  setkey(fy_year, Taxable_Income_percentile) %>%
  .[, avg_tax_rate_rel := avg_tax_rate - first(avg_tax_rate),
    keyby = .(Taxable_Income_percentile)] %>%
  .[, colour := if_else(is.na(id),
                        grey(0.5), 
                        if_else(id == "Baseline" & fy_year %in% c("2018-19", "2027-28"), 
                                if_else(fy_year == "2018-19", 
                                        gpal(6)[4],
                                        gpal(6)[5]),
                                if_else(fy_year == "2018-19", 
                                        gpal(6)[1],
                                        gpal(6)[2])))] %>%
  .[, alpha := if_else(is.na(id), 1.05 * scale01(fy2yr(fy_year)), 1)] %>%
  # .[fy_year %in% c("2013-14"), c("alpha", "colour") := list(0.8, "black")] %>%
  .[implies(!is.na(id), fy_year %in% c("2017-18", "2018-19", "2027-28"))] %>%
  .[, size := 0.8] %>%
  .[fy_year %in% c("2004-05", "2013-14"), size := 1.1] %>%
  .[fy_year %in% c("2018-19", "2027-28"), size := 1.4] %>%
  .[Taxable_Income_percentile == 50L & !is.na(id), label := paste0(id, "\n", as.character(fy_year))] %>% 
  # .[Taxable_Income_percentile == 95L & !is.na(id), label := ""] %>%
  .[] %>%
  .[, group := paste0(fy_year, colour)] %>%
  .[, text := paste0(fy_year, " ", coalesce(id, ""), "\n",
                     formatC("Percentile: ", width = 24), Taxable_Income_percentile, "\n",
                     formatC("Avg. tax rate (03-04 = 0):", width = 24), " ", 100 * round(avg_tax_rate_rel, 4))] %>%
  .[] %>%
  setnames("Taxable_Income_percentile", 
           "Taxable income percentile") %T>%
  fwrite("Average-tax-rates-relative-200304-vs-Taxable-income-percentile-by-FY.csv") %>%
  as.data.frame %>%
  # .[Over65==FALSE] %>%
  grplot(aes(x = `Taxable income percentile`,
             y = avg_tax_rate_rel,
             colour = colour,
             group = group,
             text = text)) +
  scale_color_identity() +
  scale_size_identity() +
  scale_alpha_identity() +
  geom_line(aes(alpha = 1, size = size)) +
  # geom_blank(aes(x = 105, y = 0)) +
  geom_label_repel(aes(label = label),
                   nudge_x = 2, force = 0.8,
                   na.rm = TRUE,
                   fontface = "bold",
                   label.size = NA) +
  scale_y_continuous(labels = percent) +
  ggtitle("Average tax rates relative to 2003-04") +
  theme(legend.position = "right") + 
  facet_wrap(~fy_year)
```

```{r ALP-proposal-201920-vs-taxable-income}
bound_models %>%
  .[.("2019-20", "ALP2018")] %>%
  .[, tax_saving := baseline_tax - new_tax] %>%
  .[Taxable_Income <= 300e3] %>%
  .[age_range > 1L] %>%
  .[, .(tax_saving = mean(tax_saving)),
    keyby = .(fy_year, Taxable_Income = round(Taxable_Income, -3))] %T>%
  fwrite("ALP-proposal-201920-vs-taxable-income.csv") %>%
  .[Taxable_Income %between% c(0, 225e3)] %>%
  grplot(aes(x = Taxable_Income, y = tax_saving, color = fy_year)) + 
  geom_line() +
  scale_x_continuous("Taxable income", labels = grattan_dollar, limits = c(0, 225e3)) 
```




```{r progressivities}
list(
  {
    sample_files_all %>%
      .[, .(id = "Current", fy_year = fy.year, Taxable_Income, new_tax = tax)] %>%
      .[]
  },
  s1617[, .(id = "Current", fy_year = "2016-17", Taxable_Income, new_tax)],
  s1718[, .(id = "Current", fy_year = "2017-18", Taxable_Income, new_tax)],
  bound_models[CJ(unique_fy_year, c("Budget2018", "Budget2018_baseline", "ALP2018")),
               .(id, fy_year, Taxable_Income, new_tax)]
) %>%
  rbindlist(use.names = TRUE,
            fill = TRUE)  %>%
  .[, .(progressivity = progressivity(Taxable_Income, new_tax)), keyby = c("id", "fy_year")] %>%
  .[id %chin% c("Budget2018", "Current", "Budget2018_baseline", "ALP2018")] %>%
  .[, Year := fy2yr(fy_year)] %>%
  .[id == "Budget2018_baseline", id := "Baseline"] %>%
  .[, progressivity := round(progressivity, 4)] %>%
  .[] %T>%
  fwrite("Reynolds-Smolensky-vs-year.csv") %>%
  grplot(aes(x = Year, y = progressivity, color = id, group = id)) + 
  scale_x_continuous(breaks = c(2005, 2010, 2015, 2020, 2025)) +
  geom_line() + 
  theme(legend.position = "right",
        legend.title = element_blank())
```

```{r progressivity_80}
progressivity_80 <- 
  bound_models_Grattan80 %>%
  .[.(unique_fy_year, "Budget2018")] %>%
  .[, .(progressivity = progressivity(Taxable_Income, new_tax)), keyby = c("fy_year")] %>%
  .[]
```

```{r progressivity_20}
progressivity_20 <- 
  bound_models_Grattan20 %>%
  .[.(unique_fy_year, "Budget2018")] %>%
  .[, .(progressivity = progressivity(Taxable_Income, new_tax)), keyby = c("fy_year")] %>%
  .[]
```

```{r progressivity2.75}
progressivity2.75 <- 
  bound_models_Grattan2.75 %>%
  .[.(unique_fy_year, "Budget2018"),
    .(progressivity = progressivity(Taxable_Income, new_tax)),
    keyby = c("fy_year")] %>%
  .[, id := "Wages @ 2.75%"] %>%
  .[]
```

```{r progressivity2-75-plot}
rbindlist(list(progressivity2.75,
               fread("Reynolds-Smolensky-vs-year.csv")), 
          use.names = TRUE,
          fill = TRUE) %>%
  .[id %in% c("Current", "Baseline"), id := "Current/Baseline"] %>%
  setorder(-fy_year, -progressivity) %>%
  .[, id := factor(id, levels = unique(id), ordered = TRUE)] %>%
  .[, Year := coalesce(Year, as.integer(fy2yr(fy_year))), keyby = "fy_year"] %>%
  grplot(aes(x = Year, y = progressivity,
             color = id, 
             group = id)) + 
  geom_line() + 
  theme(legend.position = "right",
        legend.title = element_blank())
```

```{r avg_tax_rates_by_percentile_facet_fy_historical}
avg_tax_rates_by_percentile_facet_fy_historical <- 
  list(
  {
    sample_files_all %>%
      .[, .(fy_year = fy.year, Taxable_Income, Taxable_Income_percentile, new_tax = tax)] %>%
      .[, id := "Current"] %>%
      set_cols_first("id") %>%
      .[]
  },
  s1718[, .(id = "Current", fy_year = "2017-18", Taxable_Income, Taxable_Income_percentile, new_tax)],
  s1617[, .(id = "Current", fy_year = "2016-17", Taxable_Income, Taxable_Income_percentile, new_tax)],
  bound_models[, .(id, fy_year, Taxable_Income, Taxable_Income_percentile, new_tax)]
) %>%
  rbindlist(use.names = TRUE,
            fill = TRUE) %>%
  .[, new_avg_tax_rate := coalesce(new_tax / Taxable_Income, 0)] %>%
  .[, .(new_avg_tax_rate = mean(new_avg_tax_rate)), 
    keyby = .(fy_year, id, Taxable_Income_percentile)] %>%
  .[] %>%
  .[implies(id %pin% "_", endsWith(id, "baseline"))] %>%
  .[id %pin% c("aseline", "urrent"), id := "Baseline/Current"] %>%
  .[order(fy_year)] %>%
  dcast(fy_year + id ~ Taxable_Income_percentile, value.var = "new_avg_tax_rate", FUN = identity) %T>%
  fwrite("avg-tax-rate-wide-by-model-fy_year.tsv", quote = TRUE, sep = "\t") %>%
  .[]
```


```{r s202728_in_1920}
s202728_in_1920 <- 
  model_income_tax(s1819,
                   "2017-18", 
                   ordinary_tax_rates = ordinary_tax_rates(10), 
                   ordinary_tax_thresholds = ordinary_tax_thresholds(10),
                   Budget2018_lamington = TRUE,
                   Budget2018_lito_202223 = TRUE)
alternative <- 
  model_income_tax(s1819, 
                   "2017-18", 
                   ordinary_tax_rates = c(0, 0.19, 0.325, 0.37, 0.45), 
                   ordinary_tax_thresholds = c(0, 18200, 37000, 90000, 180000))

r1 <- 0
while (r1 < 20 && revenue_foregone(alternative) > revenue_foregone(s202728_in_1920)) {
  print(revenue_foregone(alternative))
  r1 <- r1 + 1
  alternative <- 
    model_income_tax(s1819, 
                     "2017-18", 
                     ordinary_tax_rates = c(0, 0.19 - r1/200, 0.325 - r1/200, 0.37, 0.45), 
                     ordinary_tax_thresholds = c(0, 18200, 37000, 90000, 180000))
}

alternative %>%
  .[, new_avg_tax_rate := coalesce(new_tax / Taxable_Income, 0)] %>%
  .[, old_avg_tax_rate := coalesce(baseline_tax / Taxable_Income, 0)] %>%
  .[, delta := new_tax - baseline_tax] %>%
  .[, .(old_avg_tax_rate = mean(old_avg_tax_rate),
        new_avg_tax_rate = mean(new_avg_tax_rate),
        avg_delta = mean(delta)),
    keyby = .(Taxable_Income_percentile = ntile(Taxable_Income, 100))] %>%
  melt(id.vars = c("Taxable_Income_percentile", "avg_delta")) %>%
  .[, variable := factor(variable, levels = unique(.$variable), ordered = TRUE)] %>%
  ggplot(aes(x = Taxable_Income_percentile, y = value, color = variable)) + 
  geom_line()

baseline_share <- 
  bound_models[.("2027-28", "Budget2018_baseline"),
               .(total_delta = sum(delta)),
               keyby = .(Taxable_Income_percentile)] %>%
  .[, prop := total_delta / sum(total_delta)] 

govt_share <- 
  bound_models %>%
  .[.("2027-28", "Budget2018"),
   .(total_delta = sum(delta)),
   keyby = .(Decile = .ntile(Taxable_Income_percentile, 10))] %>%
  .[, prop := total_delta / sum(total_delta)] %>%
  fwrite("prop-share-tax-benefit-govt-by-decile.csv")

alternative_share <- 
  alternative %>%
  .[, .(total_delta = sum(delta)), keyby = .(Decile = ntile(Taxable_Income, 10))] %>%
  .[, prop := total_delta / sum(total_delta)] %>%
  fwrite("prop-share-tax-benefit-alternative-by-decile.csv")

alternative %>%
  .[, .(old_tot_tax_paid = sum(baseline_tax * WEIGHT), 
        new_tot_tax_paid = sum(new_tax * WEIGHT)), 
    keyby = .(Taxable_Income_decile = ntile(Taxable_Income, 10))] %>%
  .[] %>%
  melt.data.table(id.vars = key(.)) %>%
  ggplot(aes(x = Taxable_Income_decile, y = value, fill = variable)) + 
  geom_col(position = "dodge") + 
  scale_y_continuous(labels = function(x) paste0(grattan_dollar(x / 1e9), " bn"))
```

```{r budget2018-total-revenue-vs-fy-by-quintile.csv}
bound_models %>%
  .[.(unique_fy_year, "Budget2018"),  
    .(total_delta_bn = sum((new_tax - baseline_tax) * WEIGHT / 1e9), 
      max_income = max(Taxable_Income),
      min_income = min(Taxable_Income), 
      avg_income = mean(Taxable_Income)), 
    keyby = c("fy_year", "Quintile")] %>%
  .[, "Financial year ending" := fy2yr(.BY[[1]]), keyby = c("fy_year", "Quintile")] %>%
  .[, total_delta_bn := round(total_delta_bn, 2), keyby = c("fy_year", "Quintile")] %>%
  .[, avg_income := round(avg_income, 2), keyby = c("fy_year", "Quintile")] %>%
  setorder(fy_year, -Quintile) %>%
  fwrite("budget2018-total-revenue-vs-fy-by-quintile.csv")
```

```{r revenue_foregone2018-19-bracket-creep}
print(revenue_foregone(bound_models[.("2018-19", "Baseline_brackets_cpi")]))
```

```{r avg_tax_rate_by_percentile_brackets_cpi}
avg_tax_rate_by_percentile_brackets_cpi <-
  bound_models[.(unique_fy_year, "Baseline_brackets_cpi"),
               .(fy_year, Taxable_Income, new_tax, Taxable_Income_percentile)] %>%
  .[, avg_tax_rate := coalesce(new_tax / Taxable_Income, 0)] %>%
  .[, .(avg_tax_rate = mean(avg_tax_rate)), 
    keyby = .(fy_year, Taxable_Income_percentile)]
fwrite(avg_tax_rate_by_percentile_brackets_cpi,
       "avg_tax_rate_by_percentile_brackets_cpi.csv")

```

```{r non_taxable_individuals}
total_population_1516 <- 
  aus_pop_qtr_age(date = as.Date("2016-01-01"),
                  age = 15:100,
                  tbl = TRUE) %$%
  sum(Value) %>%
  multiply_by(s1718[1][["WEIGHT"]] / 50)
```

```{r taxable_individuals_1718}
taxable_individuals_1718 <- s1718[, sum(WEIGHT)]
```

```{r avg_tax_by_decile_allpersons201718}
avg_tax_by_decile_allpersons201718 <- 
  s1718[, .(new_tax, baseline_tax = as.double(baseline_tax), Taxable_Income, WEIGHT)] %>%
  rbind(data.table(new_tax = 0,
                   baseline_tax = 0,
                   Taxable_Income = 0L,
                   WEIGHT = total_population_1516 - taxable_individuals_1718), 
        use.names = TRUE,
        fill = TRUE) %>%
  .[, Taxable_Income_decile := weighted_ntile(Taxable_Income, WEIGHT, 10)] %>%
  .[, .(total = sum(new_tax), 
        min_income = min(Taxable_Income),
        tot_adults = sum(WEIGHT)), keyby = "Taxable_Income_decile"] %>%
  .[, share := round(total / sum(total), 3)] %T>%
  fwrite("avg_tax_by_decile_allpersons201718.csv") %>%
  .[]
```

```{r wt_rel1718v202425}
wt_rel1718v202425 <- s2425_Treasury[, first(WEIGHT)] / s1718[, first(WEIGHT)]
```

```{r wt_rel1718v202728}
wt_rel1718v202728 <- s2728_Treasury[, first(WEIGHT)] / s1718[, first(WEIGHT)]
```

```{r avg_tax_by_decile_allpersons202425}
avg_tax_by_decile_allpersons202425 <- 
  bound_models[.("2027-28", "Budget2018"),
               .(new_tax, baseline_tax, Taxable_Income, WEIGHT)] %>%
  rbind(data.table(new_tax = 0,
                   baseline_tax = 0,
                   Taxable_Income = 0L,
                   WEIGHT = wt_rel1718v202425 * (total_population_1516 - taxable_individuals_1718)), 
        use.names = TRUE, fill = TRUE) %>%
  .[, Taxable_Income_decile := weighted_ntile(Taxable_Income, WEIGHT, 10)] %>%
  .[, .(total = sum(new_tax), 
        min_income = min(Taxable_Income),
        tot_adults = sum(WEIGHT)),
    keyby = "Taxable_Income_decile"] %>%
  .[, share := round(total / sum(total), 3)] %T>%
  fwrite("avg_tax_by_decile_allpersons202425.csv") %>%
  .[]
```



```{r avg_tax_by_decile_allpersons202728}
avg_tax_by_decile_allpersons202728 <- 
  bound_models[.("2027-28", "Budget2018"),
                .(new_tax, baseline_tax, Taxable_Income, WEIGHT)] %>%
  rbind(data.table(new_tax = 0,
                   baseline_tax = 0,
                   Taxable_Income = 0L,
                   WEIGHT = wt_rel1718v202728 * (total_population_1516 - taxable_individuals_1718)), 
        use.names = TRUE, fill = TRUE) %>%
  .[, Taxable_Income_decile := weighted_ntile(Taxable_Income, WEIGHT, 10)] %>%
  .[, .(total = sum(new_tax), 
        min_income = min(Taxable_Income),
        tot_adults = sum(WEIGHT)), keyby = "Taxable_Income_decile"] %>%
  .[, share := round(total / sum(total), 3)] %T>%
  fwrite("avg_tax_by_decile_allpersons202728.csv") %>%
  .[]
```

```{r avg_tax_by_quintile_allpersons201718}
avg_tax_by_quintile_allpersons201718 <- 
  avg_tax_by_decile_allpersons201718 %>%
  .[, .(total = sum(total)), keyby = .(Quintile = ceiling(Taxable_Income_decile / 2))] %>%
  .[, share := total / sum(total)] %T>%
  fwrite("avg_tax_by_quintile_allpersons201718.csv") %>%
  .[]
```

```{r avg_tax_by_quintile_allpersons202425}
avg_tax_by_quintile_allpersons202425 <- 
  avg_tax_by_decile_allpersons202425 %>%
  .[, .(total = sum(total)), keyby = .(Quintile = ceiling(Taxable_Income_decile / 2))] %>%
  .[, share := total / sum(total)] %T>%
  fwrite("avg_tax_by_quintile_allpersons202425.csv") %>%
  .[]
```


```{r decile201718}
decile201718 <- 
  s1718[, .(new_tax, baseline_tax = as.double(baseline_tax), Taxable_Income, WEIGHT)] %>%
  rbind(data.table(new_tax = 0,
                   baseline_tax = 0,
                   Taxable_Income = 0L,
                   WEIGHT = total_population_1516 - sample_files_all[.("2015-16"), sum(WEIGHT)]), 
        use.names = TRUE,
        fill = TRUE) %>%
  .[, Taxable_Income_decile := weighted_ntile(Taxable_Income, WEIGHT, 10)] %>%
  .[, .(Taxable_Income = min(Taxable_Income),
        tot = sum(baseline_tax * WEIGHT / 1e9)),
    keyby = .(Taxable_Income_decile)] %>%
  .[, min_Taxable_Income := round(Taxable_Income, -3)] %>%
  .[, prop := tot / sum(tot)] %>%
  setkey(Taxable_Income) %>%
  .[]
```


```{r prop-tax-paid-deloitte-technique-202425}
bound_models[.("2024-25", "Budget2018"),
              .(new_tax, baseline_tax, Taxable_Income, WEIGHT)] %>%
  rbind(data.table(new_tax = 0,
                   baseline_tax = 0,
                   Taxable_Income = 0L,
                   WEIGHT = wt_rel1718v202728 * (total_population_1516 - taxable_individuals_1718)), 
        use.names = TRUE, fill = TRUE) %>%
  setkey(Taxable_Income) %>%
  decile201718[., roll = TRUE] %>%
  .[, .(tot = sum(new_tax * WEIGHT / 1e9)), keyby = .(Taxable_Income_decile, min_Taxable_Income)] %>%
  .[, prop := tot / sum(tot)] %>%
  .[] %>%
  .[, .(Decile = Taxable_Income_decile, 
        `Min income` = grattan_dollar(min_Taxable_Income),
        `Tax paid ($bn)` = tot,
        `% paid` = prop)] %>%
  kable
```

```{r prop-tax-paid-deloitte-technique-202728}
bound_models[.("2027-28", "Budget2018"),
             .(new_tax, baseline_tax, Taxable_Income, WEIGHT)] %>%
  rbind(data.table(new_tax = 0,
                   baseline_tax = 0,
                   Taxable_Income = 0L,
                   WEIGHT = wt_rel1718v202728 * (total_population_1516 - taxable_individuals_1718)), 
        use.names = TRUE, fill = TRUE) %>%
  .[, .(new_tax, baseline_tax, Taxable_Income, WEIGHT)] %>%
  setkey(Taxable_Income) %>%
  decile201718[., roll = TRUE] %>%
  .[, .(tot = sum(new_tax)), keyby = .(Taxable_Income_decile, min_Taxable_Income)] %>%
  .[, prop := tot / sum(tot)] %>%
  .[] %>%
  .[, .(Decile = Taxable_Income_decile, 
        `Min income` = grattan_dollar(min_Taxable_Income),
        `Tax paid ($bn)` = tot,
        `% paid` = prop)] %>%
  kable
```


```{r s2728_various_wages}
s2728_various_wages <-
  if (file.exists(s2728_various_wages.fst <- "budget-2018_cache/s2728_various_wages.fst") && cache) {
    read_fst(s2728_various_wages.fst, as.data.table = TRUE)
  } else {
    lapply(c(0.02, 0.025, 0.03, 0.035), function(wage_r) {
      project(sample_file_1516, h = 12L, wage.series = wage_r) %>%
        grattan::model_income_tax(
          baseline_fy = "2017-18",
          medicare_levy_lower_threshold = medicare_levy_lower_threshold("2027-28"),
          medicare_levy_lower_sapto_threshold = medicare_levy_lower_sapto_threshold("2027-28"),
          medicare_levy_lower_family_threshold = medicare_levy_lower_family_threshold("2027-28"),
          medicare_levy_lower_family_sapto_threshold = medicare_levy_lower_family_sapto_threshold("2027-28"),
          medicare_levy_lower_up_for_each_child = medicare_levy_lower_up_for_each_child("2027-28"),
          warn_upper_thresholds = FALSE,
          Budget2018_lamington = FALSE,
          Budget2018_lito_202223 = TRUE,
          Budget2018_watr = FALSE,
          ordinary_tax_thresholds = ordinary_tax_thresholds("2027-28"),
          ordinary_tax_rates = ordinary_tax_rates("2027-28")) %>%
        .[, .(Ind, age_range, Total_PP_BE_amt, Total_NPP_BE_amt,
              Taxable_Income, new_tax, baseline_tax, WEIGHT,
              id = wage_r)] 
    }) %>%
      rbindlist(use.names = TRUE, fill = TRUE) %>%
      .[, new_tax := as.integer(new_tax)] %>%
      .[, delta := new_tax - baseline_tax] %T>%
      write_fst(s2728_various_wages.fst) %>%
      .[]
  }
```

```{r comparison-wage-assumptions}
compare_avg_tax_rates(s2728_various_wages, s1718[, baseline_tax := tax]) %>%
  .[, "Wage assumption" := factor(percent(id))] %T>%
  fwrite("compare-avg-tax-rates-2027-28-wage-assumptions.csv") %>%
  grplot(aes(x = Taxable_Income_percentile,
             y = delta_avgTaxRate,
             color = `Wage assumption`,
             group = `Wage assumption`)) +
  geom_line() + 
  xlab("Taxable Income percentile") +
  guides(color = guide_legend(reverse = TRUE)) +
  theme(legend.position = c(1, 1), 
        legend.justification = c(1, 1))

```

```{r prop_tax_paid_before_2025}
bound_models[.(yr2fy(2019:2025), "Budget2018")] %>%
  .[, new_tax := as.double(new_tax)] %>%
  .[, .(tot_tax = sum(new_tax)),
    keyby = .(fy2018 = id,#  if_else(fy_year == "2018-19", "2018-19", "2019-20 - 2024-25"),
              Quintile = weighted_ntile(Taxable_Income, n = 5))] %>%
  .[, p := tot_tax / sum(tot_tax), keyby = "fy2018"] %>%
  .[]
```

```{r adult_population_projections}
adult_population_projections <- 
  lapply(as.Date(paste0(2001:2016, "-06-30")), aus_pop_qtr_age, age = 18:100, tbl = TRUE) %>%
  rbindlist %>% 
  .[, .(pop = sum(Value)), keyby = "Date"] %$% 
  forecast::forecast(pop, h = 12) %>%
  as.data.frame %>%
  dplyr::mutate(YR = as.integer(rownames(.)) + 2000L) %>%
  as.data.table %>%
  melt(id.vars = "YR")

adult_population_projections %>%
  {
    dot <- .
    ribbon <- 
      dot[variable %enotin% "Point Forecast"] %>%
      .[, c("LowHi", "Level") := tstrsplit(variable, split = " ")] %>%
      .[, variable := NULL] %>%
      dcast(... ~ LowHi, value.var = "value") %>%
      .[, Level := as.integer(Level)]
    
    grplot(dot) + 
      geom_ribbon(data = ribbon[Level == 80L], 
                  aes(x = YR, ymin = Lo, ymax = Hi), 
                  alpha = 0.4) +
      geom_ribbon(data = ribbon[Level == 95L], 
                  aes(x = YR, ymin = Lo, ymax = Hi), 
                  alpha = 0.3) +
      geom_line(data = dot[variable %ein% "Point Forecast"], 
                aes(x = YR, y = value, color = variable)) +
      geom_hline(yintercept = 22.37e6) + 
      geom_vline(xintercept = 2024) +
      scale_y_continuous(label = function(x) paste0(x / 1e6, "M"))
  }

```

```{r comparison-deloitte-ntaxpayers}
s1516 <- copy(sample_file_1516)[, tax := income_tax(Taxable_Income, "2015-16", .dots.ATO = .SD)]
n_taxpayers_1516 <- s1516[tax > 1, .N * 50]
n_taxpayers_1718 <- s1718[tax > 1, sum(WEIGHT)]


v <- (1 / (2025 - 2016))
deloitte_wage_r <- (11.6e6 / n_taxpayers_1516) ^ v
budget_wage_r <- 
  (bound_models[.("2024-25", "Budget2018")][new_tax > 1, sum(WEIGHT)] / n_taxpayers_1516) ^ v
```

```{r comparison-deloitte-adults}
adultpop2016 <- sum(aus_pop_qtr_age(date = as.Date("2016-06-30"), age = 18:100))
deloitte_pop_r <- (22.37e6 / adultpop2016) ^ v
budget_pop_r <- 
  adult_population_projections %>%
  .[YR == 2025] %>%
  .[variable == "Point Forecast", (value / adultpop2016) ^ v]
  
```

Growth assumptions:

  * Number of taxpayers:
    * Deloitte: `r percent(deloitte_wage_r - 1)`
    * Budget: `r percent(budget_wage_r - 1)`
  * Number of adults: 
    * Deloitte: `r percent(deloitte_pop_r - 1)`
    * Grattan: `r percent(budget_pop_r - 1)`

```{r comparison-lf-assumptions}
s2425_Deloitte_LF_growth <- 
  project(sample_file_1516, h = 9L) %>%
  model_income_tax(baseline_fy = "2017-18", 
                   ordinary_tax_thresholds = ordinary_tax_thresholds("2024-25"), 
                   ordinary_tax_rates = ordinary_tax_rates("2024-25"),
                   Budget2018_lito_202223 = TRUE,
                   medicare_levy_rate = 0.02,
                   medicare_levy_taper = 0.1,
                   medicare_levy_lower_threshold = 24750, # medicare_levy_lower_threshold("2024-25")
                   medicare_levy_upper_threshold = 30938,
                   medicare_levy_lower_sapto_threshold = medicare_levy_lower_sapto_threshold("2024-25"),
                   medicare_levy_upper_sapto_threshold = 48912,
                   medicare_levy_lower_family_threshold = 54930, # medicare_levy_lower_family_threshold("2024-25")
                   medicare_levy_lower_family_sapto_threshold = 54930) %>% # medicare_levy_lower_family_sapto_threshold("2024-25")) %>% # 54930
  # Ensure number of taxpayers = 11.6 million
  .[new_tax >= 1, WEIGHT := 11.6e6 / sum(new_tax > 0)] %>%
  
  # Ensure total population is 22.37 million
  .[, WEIGHT := WEIGHT * if_else(new_tax < 1,
                                 1 + (22.37e6 - 11.6e6 - sum(WEIGHT[new_tax < 1])) / sum(WEIGHT[new_tax < 1]),
                                 1)]

stopifnot(s2425_Deloitte_LF_growth[new_tax > 1, sum(WEIGHT)] %between% c(11.5e6, 11.7e6))
stopifnot(s2425_Deloitte_LF_growth[, sum(WEIGHT)] %between% c(22.2e6, 22.4e6))

s2425_Deloitte_LF_growth %>%
  .[, .(total_tax_paid = sum(new_tax * WEIGHT)),
    keyby = .(Quintile = weighted_ntile(Taxable_Income, weights = WEIGHT, n = 5))] %>%
  .[, p := total_tax_paid / sum(total_tax_paid)] %>%
  .[]

```

```{r minIncome_by_Quintile_Deloitte_method201718}
minIncome_by_Quintile_Deloitte_method201718 <-
  avg_tax_by_decile_allpersons201718 %>%
  .[, .(minIncome = round(min(min_income), -3)),
    keyby = .(Quintile = {{Taxable_Income_decile - 1L} %/% 2L} + 1L)]
fwrite(minIncome_by_Quintile_Deloitte_method201718, 
       "minIncome_by_Quintile_Deloitte_method201718.csv")
```

```{r minIncome_by_Quintile_Deloitte_method202425}
minIncome_by_Quintile_Deloitte_method202425 <-
  avg_tax_by_decile_allpersons202425 %>%
  .[, .(minIncome = round(min(min_income), -3)),
    keyby = .(Quintile = {{Taxable_Income_decile - 1L} %/% 2L} + 1L)]
fwrite(minIncome_by_Quintile_Deloitte_method202425, 
       "minIncome_by_Quintile_Deloitte_method202425.csv")
```


## JD 'How not to sell a tax cut'

```{r p_geq_120k_202728}
p_geq_120k_202728 <- 
  bound_models[.("2027-28", "Budget2018")] %$%
  mean(Taxable_Income > 120e3)
stopifnot(round(p_geq_120k_202728, 1) == 0.2)
```

Of course, a tax cut of \$14 billion a year is a tricky sell when it benefits less than 2 in 10 of income earners in 2027-28. But the government has made its own life harder by using misleading statistics and not providing the numbers that could support its best argument.


```{r current_tax_paid_geq_180k}
current_tax_paid_geq_180k <- 
  s1718 %>%
  .[, tax := income_tax(Taxable_Income, "2017-18", .dots.ATO = s1718)] %>%
  .[, .(Taxable_Income, tax)] %>%
  .[, .(tot = sum(tax)), keyby = .(Over180k = Taxable_Income > 180e3)] %>%
  .[, prop := tot / sum(tot)] %>%
  .[(Over180k)] %>%
  .[["prop"]] %>%
  grattan_percent(.percent.suffix = " per cent")

tax_paid_geq180k_Budget202728 <- 
  bound_models[.("2027-28", "Budget2018")] %>%
  .[, .(Taxable_Income, tax = as.double(new_tax))] %>%
  .[, .(tot = sum(tax)), keyby = .(Over180k = Taxable_Income > 180e3)] %>%
  .[, prop := tot / sum(tot)] %>%
  .[(Over180k)] %>%
  .[["prop"]] %>%
  grattan_percent(.percent.suffix = " per cent")

prop_persons_geq180k_201718 <-
  s1718[, .(n = .N), keyby = .(Over180k = Taxable_Income > 180e3)] %>%
  .[, prop := n / sum(n)] %>%
  .[(Over180k)] %>%
  .[["prop"]]

prop_persons_geq180k_Budget202728 <- 
   bound_models[.("2027-28", "Budget2018")] %>%
  .[, .(tot = sum(WEIGHT)), keyby = .(Over180k = Taxable_Income > 180e3)] %>%
  .[, prop := tot / sum(tot)] %>%
  .[(Over180k)] %>%
  .[["prop"]]

stopifnot(!exists("twice1"))
twice1 <- 
  if (prop_persons_geq180k_Budget202728 / prop_persons_geq180k_201718 > 2) {
    "twice"
  } else {
    twice1
  }
```

Another tricky claim is that without change those earning over \$180,000 will go from paying `r current_tax_paid_geq_180k` to `r tax_paid_geq180k_Budget202728` of income tax. But this is sleight of hand: `r twice1` as many people could be expected to be earning this income -- so of course they will collectively pay a greater share of income tax.

```{r prop_tax_earnt_by_quintile_201718}
prop_tax_earnt_by_quintile_201718 <- 
  s1718[,
        .(tax_earnt_bn = sum(Taxable_Income * WEIGHT / 1e9)),
        keyby = .(Quintile = ntile(Taxable_Income, 5))] %>%
  .[, prop := tax_earnt_bn / sum(tax_earnt_bn)] %>%
  .[]

prop_tax_paid_by_quintile_202728_baseline <- 
  bound_models[.("2027-28", "Budget2018")] %>%
  .[, .(tax_paid = sum(as.numeric(new_tax))), keyby = .(Quintile = ntile(Taxable_Income, 5))] %>%
  .[, prop := tax_paid / sum(tax_paid)] %>%
  .[]

prop_tax_paid_by_quintile_202728_Budget <- 
  bound_models[.("2027-28", "Budget2018")] %>%
  .[, .(tax_paid = sum(as.numeric(new_tax))), keyby = .(Quintile = ntile(Taxable_Income, 5))] %>%
  .[, prop := tax_paid / sum(tax_paid)] %>%
  .[]
```

The government's best and most honest argument is that the tax package as a whole won't materially change the progressivity of the income tax system. Without change, the top 20\% of income earners -- who earn 
`r grattan_percent(prop_tax_earnt_by_quintile_201718[.(5L)][["prop"]])`
per cent of taxable income -- will pay `r grattan_percent(prop_tax_paid_by_quintile_202728_baseline[.(5L)][["prop"]], digits = 3)` of income tax.
And under the package they will pay `r grattan_percent(prop_tax_paid_by_quintile_202728_Budget[.(5L)][["prop"]], digits = 4)`.

## Applying timings

We can apply timing issues: 85\% revenue is tax revenue and 15\% at the time of assessment for those under \$180,000; 75\% and 25\% at time of assessment.

```{r bound_models_with_timings}
# setindex(bound_models, id)
bound_models_with_timings <- 
  lapply(c(FALSE, TRUE), function(x) {
    bound_models[.(unique_fy_year, "Budget2018"),
                 .(id,
                   YearOfAssessment = x,
                   fy_year2 = if (x) yr2fy(fy2yr(.BY[[1L]]) + x) else .BY[[1L]],
                   Ind,
                   Taxable_Income,
                   delta,
                   WEIGHT), 
                 keyby = "fy_year"][, fy_year := NULL]
  }) %>%
  rbindlist() %>%
  .[(Taxable_Income > 180e3), WEIGHT := if_else(YearOfAssessment, 0.25, 0.75) * WEIGHT] %>%
  .[(Taxable_Income <= 180e3), WEIGHT := if_else(YearOfAssessment, 0.15, 0.85) * WEIGHT] %>%
  .[, .(tot = sum(delta * WEIGHT / 1e9)), keyby = "fy_year2"]
```



```{r session_info}
devtools::session_info()
```

Finished in `r as.character(ceiling(difftime(Sys.time(), START.TIME, unit = "sec"))) %T>% writeLines("budget-2018-duration.txt") %>% identity`.
