
#include "grattan.h"


int ORDINARY_TAX_BRACKETS_1984[MAX_NBRACK] = {0, 4595, 19500, 35788, INT_MAX, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1985[MAX_NBRACK] = {0, 4595, 12500, 19500, 28000, 35000, 35788, INT_MAX};
int ORDINARY_TAX_BRACKETS_1986[MAX_NBRACK] = {0, 4595, 12500, 19500, 28000, 35000, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1987[MAX_NBRACK] = {0, 4890, 12500, 12600, 19500, 28000, 35000, INT_MAX};
int ORDINARY_TAX_BRACKETS_1988[MAX_NBRACK] = {0, 5100, 12600, 19500, 35000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1989[MAX_NBRACK] = {0, 5100, 12600, 19500, 35000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1990[MAX_NBRACK] = {0, 5100, 17650, 20600, 35000, 50000, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1991[MAX_NBRACK] = {0, 5250, 17650, 20600, 20700, 35000, 36000, 50000};
int ORDINARY_TAX_BRACKETS_1992[MAX_NBRACK] = {0, 5400, 20700, 36000, 50000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1993[MAX_NBRACK] = {0, 5400, 20700, 36000, 50000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1994[MAX_NBRACK] = {0, 5400, 20700, 36000, 38000, 50000, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1995[MAX_NBRACK] = {0, 5400, 20700, 38000, 50000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1996[MAX_NBRACK] = {0, 5400, 20700, 38000, 50000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1997[MAX_NBRACK] = {0, 5400, 20700, 38000, 50000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1998[MAX_NBRACK] = {0, 5400, 20700, 38000, 50000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_1999[MAX_NBRACK] = {0, 5400, 20700, 38000, 50000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2000[MAX_NBRACK] = {0, 5400, 20700, 38000, 50000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2001[MAX_NBRACK] = {0, 6000, 20000, 50000, 60000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2002[MAX_NBRACK] = {0, 6000, 20000, 50000, 60000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2003[MAX_NBRACK] = {0, 6000, 20000, 50000, 60000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2004[MAX_NBRACK] = {0, 6000, 21600, 52000, 62500, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2005[MAX_NBRACK] = {0, 6000, 21600, 58000, 70000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2006[MAX_NBRACK] = {0, 6000, 21600, 63000, 95000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2007[MAX_NBRACK] = {0, 6000, 25000, 75000, 150000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2008[MAX_NBRACK] = {0, 6000, 30000, 75000, 150000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2009[MAX_NBRACK] = {0, 6000, 34000, 80000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2010[MAX_NBRACK] = {0, 6000, 35000, 80000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2011[MAX_NBRACK] = {0, 6000, 37000, 80000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2012[MAX_NBRACK] = {0, 6000, 37000, 80000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2013[MAX_NBRACK] = {0, 18200, 37000, 80000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2014[MAX_NBRACK] = {0, 18200, 37000, 80000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2015[MAX_NBRACK] = {0, 18200, 37000, 80000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2016[MAX_NBRACK] = {0, 18200, 37000, 80000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2017[MAX_NBRACK] = {0, 18200, 37000, 87000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2018[MAX_NBRACK] = {0, 18200, 37000, 87000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2019[MAX_NBRACK] = {0, 18200, 37000, 90000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2020[MAX_NBRACK] = {0, 18200, 37000, 90000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2021[MAX_NBRACK] = {0, 18200, 37000, 90000, 180000, INT_MAX, INT_MAX, INT_MAX};
int ORDINARY_TAX_BRACKETS_2022[MAX_NBRACK] = {0, 18200, 37000, 90000, 180000, INT_MAX, INT_MAX, INT_MAX};

double ORDINARY_TAX_RATES_1984[MAX_NBRACK] = {0, 0.30, 0.46, 0.60, 0.60, 0.60, 0.60, 0.60};
double ORDINARY_TAX_RATES_1985[MAX_NBRACK] = {0, 0.2667, 0.30, 0.46, 0.4733, 0.5533, 0.60, 0.60};
double ORDINARY_TAX_RATES_1986[MAX_NBRACK] = {0, 0.25, 0.30, 0.46, 0.48, 0.60, 0.60, 0.60};
double ORDINARY_TAX_RATES_1987[MAX_NBRACK] = {0, 0.2442, 0.2650, 0.2942, 0.4425, 0.4683, 0.5708, 0.5708};
double ORDINARY_TAX_RATES_1988[MAX_NBRACK] = {0, 0.24, 0.29, 0.40, 0.49, 0.49, 0.49, 0.49};
double ORDINARY_TAX_RATES_1989[MAX_NBRACK] = {0, 0.24, 0.29, 0.40, 0.49, 0.49, 0.49, 0.49};
double ORDINARY_TAX_RATES_1990[MAX_NBRACK] = {0, 0.21, 0.29, 0.39, 0.47, 0.48, 0.48, 0.48};
double ORDINARY_TAX_RATES_1991[MAX_NBRACK] = {0, 0.205, 0.245, 0.295, 0.385, 0.425, 0.465, 0.47};
double ORDINARY_TAX_RATES_1992[MAX_NBRACK] = {0, 0.2, 0.38, 0.46, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_1993[MAX_NBRACK] = {0, 0.2, 0.38, 0.46, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_1994[MAX_NBRACK] = {0, 0.2, 0.355, 0.385, 0.44125, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_1995[MAX_NBRACK] = {0, 0.2, 0.34, 0.43, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_1996[MAX_NBRACK] = {0, 0.2, 0.34, 0.43, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_1997[MAX_NBRACK] = {0, 0.2, 0.34, 0.43, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_1998[MAX_NBRACK] = {0, 0.2, 0.34, 0.43, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_1999[MAX_NBRACK] = {0, 0.2, 0.34, 0.43, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_2000[MAX_NBRACK] = {0, 0.2, 0.34, 0.43, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_2001[MAX_NBRACK] = {0, 0.17, 0.3, 0.42, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_2002[MAX_NBRACK] = {0, 0.17, 0.3, 0.42, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_2003[MAX_NBRACK] = {0, 0.17, 0.3, 0.42, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_2004[MAX_NBRACK] = {0, 0.17, 0.3, 0.42, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_2005[MAX_NBRACK] = {0, 0.17, 0.3, 0.42, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_2006[MAX_NBRACK] = {0, 0.15, 0.3, 0.42, 0.47, 0.47, 0.47, 0.47};
double ORDINARY_TAX_RATES_2007[MAX_NBRACK] = {0, 0.15, 0.3, 0.4, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2008[MAX_NBRACK] = {0, 0.15, 0.3, 0.4, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2009[MAX_NBRACK] = {0, 0.15, 0.3, 0.4, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2010[MAX_NBRACK] = {0, 0.15, 0.3, 0.38, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2011[MAX_NBRACK] = {0, 0.15, 0.3, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2012[MAX_NBRACK] = {0, 0.15, 0.3, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2013[MAX_NBRACK] = {0, 0.19, 0.325, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2014[MAX_NBRACK] = {0, 0.19, 0.325, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2015[MAX_NBRACK] = {0, 0.19, 0.325, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2016[MAX_NBRACK] = {0, 0.19, 0.325, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2017[MAX_NBRACK] = {0, 0.19, 0.325, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2018[MAX_NBRACK] = {0, 0.19, 0.325, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2019[MAX_NBRACK] = {0, 0.19, 0.325, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2020[MAX_NBRACK] = {0, 0.19, 0.325, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2021[MAX_NBRACK] = {0, 0.19, 0.325, 0.37, 0.45, 0.45, 0.45, 0.45};
double ORDINARY_TAX_RATES_2022[MAX_NBRACK] = {0, 0.19, 0.325, 0.37, 0.45, 0.45, 0.45, 0.45};

int nb_by_year(unsigned int yr) {
  if (yr > 1995) {
    return 5;
  }
  switch(yr) {
  case 1984:
    return 4;
  case 1985:
  case 1987:
    return 7;
  case 1986:
  case 1990:
  case 1994:
    return 6;
  case 1991:
    return 8;
  default:
    return 5;
  }
}

unsigned int brack_by_yr(int b, int yr) {
  switch(yr) {
  case 1984:
    return ORDINARY_TAX_BRACKETS_1984[b];
    break;
  case 1985:
    return ORDINARY_TAX_BRACKETS_1985[b];
    break;
  case 1986:
    return ORDINARY_TAX_BRACKETS_1986[b];
    break;
  case 1987:
    return ORDINARY_TAX_BRACKETS_1987[b];
    break;
  case 1988:
    return ORDINARY_TAX_BRACKETS_1988[b];
    break;
  case 1989:
    return ORDINARY_TAX_BRACKETS_1989[b];
    break;
  case 1990:
    return ORDINARY_TAX_BRACKETS_1990[b];
    break;
  case 1991:
    return ORDINARY_TAX_BRACKETS_1991[b];
    break;
  case 1992:
    return ORDINARY_TAX_BRACKETS_1992[b];
    break;
  case 1993:
    return ORDINARY_TAX_BRACKETS_1993[b];
    break;
  case 1994:
    return ORDINARY_TAX_BRACKETS_1994[b];
    break;
  case 1995:
    return ORDINARY_TAX_BRACKETS_1995[b];
    break;
  case 1996:
    return ORDINARY_TAX_BRACKETS_1996[b];
    break;
  case 1997:
    return ORDINARY_TAX_BRACKETS_1997[b];
    break;
  case 1998:
    return ORDINARY_TAX_BRACKETS_1998[b];
    break;
  case 1999:
    return ORDINARY_TAX_BRACKETS_1999[b];
    break;
  case 2000:
    return ORDINARY_TAX_BRACKETS_2000[b];
    break;
  case 2001:
    return ORDINARY_TAX_BRACKETS_2001[b];
    break;
  case 2002:
    return ORDINARY_TAX_BRACKETS_2002[b];
    break;
  case 2003:
    return ORDINARY_TAX_BRACKETS_2003[b];
    break;
  case 2004:
    return ORDINARY_TAX_BRACKETS_2004[b];
    break;
  case 2005:
    return ORDINARY_TAX_BRACKETS_2005[b];
    break;
  case 2006:
    return ORDINARY_TAX_BRACKETS_2006[b];
    break;
  case 2007:
    return ORDINARY_TAX_BRACKETS_2007[b];
    break;
  case 2008:
    return ORDINARY_TAX_BRACKETS_2008[b];
    break;
  case 2009:
    return ORDINARY_TAX_BRACKETS_2009[b];
    break;
  case 2010:
    return ORDINARY_TAX_BRACKETS_2010[b];
    break;
  case 2011:
    return ORDINARY_TAX_BRACKETS_2011[b];
    break;
  case 2012:
    return ORDINARY_TAX_BRACKETS_2012[b];
    break;
  case 2013:
    return ORDINARY_TAX_BRACKETS_2013[b];
    break;
  case 2014:
    return ORDINARY_TAX_BRACKETS_2014[b];
    break;
  case 2015:
    return ORDINARY_TAX_BRACKETS_2015[b];
    break;
  case 2016:
    return ORDINARY_TAX_BRACKETS_2016[b];
    break;
  case 2017:
    return ORDINARY_TAX_BRACKETS_2017[b];
    break;
  case 2018:
    return ORDINARY_TAX_BRACKETS_2018[b];
    break;
  case 2019:
    return ORDINARY_TAX_BRACKETS_2019[b];
    break;
  case 2020:
    return ORDINARY_TAX_BRACKETS_2020[b];
    break;
  case 2021:
    return ORDINARY_TAX_BRACKETS_2021[b];
    break;
  case 2022:
    return ORDINARY_TAX_BRACKETS_2022[b];
    break;
  default:
    return ORDINARY_TAX_BRACKETS_2022[b];
  }
  return 0;
}

SEXP Cbracks_by_year(SEXP Yr, SEXP bb) {
  int yr = asInteger(Yr);
  const int * b = INTEGER(bb);
  int n = length(bb);
  if (n > 8) {
    n = 8;
  }
  SEXP ans = PROTECT(allocVector(INTSXP, n));
  for (int i = 0; i < n; ++i) {
    INTEGER(ans)[i] = brack_by_yr(b[i] - 1, yr);
  }
  UNPROTECT(1);
  return ans;
}

double rates_by_yr(int b, int yr) {
  switch(yr) {
  case 1984:
    return ORDINARY_TAX_RATES_1984[b];
    break;
  case 1985:
    return ORDINARY_TAX_RATES_1985[b];
    break;
  case 1986:
    return ORDINARY_TAX_RATES_1986[b];
    break;
  case 1987:
    return ORDINARY_TAX_RATES_1987[b];
    break;
  case 1988:
    return ORDINARY_TAX_RATES_1988[b];
    break;
  case 1989:
    return ORDINARY_TAX_RATES_1989[b];
    break;
  case 1990:
    return ORDINARY_TAX_RATES_1990[b];
    break;
  case 1991:
    return ORDINARY_TAX_RATES_1991[b];
    break;
  case 1992:
    return ORDINARY_TAX_RATES_1992[b];
    break;
  case 1993:
    return ORDINARY_TAX_RATES_1993[b];
    break;
  case 1994:
    return ORDINARY_TAX_RATES_1994[b];
    break;
  case 1995:
    return ORDINARY_TAX_RATES_1995[b];
    break;
  case 1996:
    return ORDINARY_TAX_RATES_1996[b];
    break;
  case 1997:
    return ORDINARY_TAX_RATES_1997[b];
    break;
  case 1998:
    return ORDINARY_TAX_RATES_1998[b];
    break;
  case 1999:
    return ORDINARY_TAX_RATES_1999[b];
    break;
  case 2000:
    return ORDINARY_TAX_RATES_2000[b];
    break;
  case 2001:
    return ORDINARY_TAX_RATES_2001[b];
    break;
  case 2002:
    return ORDINARY_TAX_RATES_2002[b];
    break;
  case 2003:
    return ORDINARY_TAX_RATES_2003[b];
    break;
  case 2004:
    return ORDINARY_TAX_RATES_2004[b];
    break;
  case 2005:
    return ORDINARY_TAX_RATES_2005[b];
    break;
  case 2006:
    return ORDINARY_TAX_RATES_2006[b];
    break;
  case 2007:
    return ORDINARY_TAX_RATES_2007[b];
    break;
  case 2008:
    return ORDINARY_TAX_RATES_2008[b];
    break;
  case 2009:
    return ORDINARY_TAX_RATES_2009[b];
    break;
  case 2010:
    return ORDINARY_TAX_RATES_2010[b];
    break;
  case 2011:
    return ORDINARY_TAX_RATES_2011[b];
    break;
  case 2012:
    return ORDINARY_TAX_RATES_2012[b];
    break;
  case 2013:
    return ORDINARY_TAX_RATES_2013[b];
    break;
  case 2014:
    return ORDINARY_TAX_RATES_2014[b];
    break;
  case 2015:
    return ORDINARY_TAX_RATES_2015[b];
    break;
  case 2016:
    return ORDINARY_TAX_RATES_2016[b];
    break;
  case 2017:
    return ORDINARY_TAX_RATES_2017[b];
    break;
  case 2018:
    return ORDINARY_TAX_RATES_2018[b];
    break;
  case 2019:
    return ORDINARY_TAX_RATES_2019[b];
    break;
  case 2020:
    return ORDINARY_TAX_RATES_2020[b];
    break;
  case 2021:
    return ORDINARY_TAX_RATES_2021[b];
    break;
  case 2022:
    return ORDINARY_TAX_RATES_2022[b];
    break;
  default:
    return ORDINARY_TAX_RATES_2022[b];
  }
  return 0; // # nocov
}

SEXP Crates_by_yr(SEXP Yr, SEXP bb) {
  int yr = asInteger(Yr);
  const int * b = INTEGER(bb);
  int n = length(bb);
  if (n > 8) {
    n = 8;
  }
  SEXP ans = PROTECT(allocVector(REALSXP, n));
  for (int i = 0; i < n; ++i) {
    REAL(ans)[i] = rates_by_yr(b[i] - 1, yr);
  }
  UNPROTECT(1);
  return ans;
}

System yr2System(int yr) {
  if (yr > 2022) {
    return System2022;
  }
  switch(yr) {
  case 2011:
    return System2011;
  case 2012:
    return System2012;
  case 2013:
    return System2013;
  case 2014:
    return System2014;
  case 2015:
    return System2015;
  case 2016:
    return System2016;
  case 2017:
    return System2017;
  case 2018:
    return System2018;
  case 2019:
    return System2019;
  case 2020:
    return System2020;
  case 2021:
    return System2021;
  case 2022:
    return System2022;
  }
  System Sys;
  Sys.yr = yr;
  int nb = nb_by_year(yr);
  Sys.nb = nb;
  for (int b = 0; b < MAX_NBRACK; ++b) {
    Sys.BRACKETS[b] = brack_by_yr(b, yr);
    Sys.RATES[b] = rates_by_yr(b, yr);
  }
  Sys.M = yr2Medicare(yr);
  Sys.has_sapto = yr >= 2000;
  Sys.S = yr2Sapto(yr);
  Sys.has_temp_budget_repair_levy = yr >= 2015 && yr <= 2017;
  return Sys;
}

// quick trunc
int qtrunc(double x) {
  if (x > INT_MAX) {
    return INT_MAX;
  }
  if (x <= -INT_MAX) {
    return -INT_MAX;
  }
  return (int)x;
}

bool safe2int(double x) {
  return !ISNAN(x) && x > -INT_MAX && x < INT_MAX;
}







void setIntElement(int * o, SEXP list, const char * str) {
  SEXP elmt = getListElement(list, str);
  if (isReal(elmt)) {
    double delmt = asReal(elmt);
    if (!safe2int(delmt)) {
      return;
    }
    *o = (int)delmt;
    return;
  }
  if (isInteger(elmt)) {
    *o = asInteger(elmt);
  }
}

void setIntElements(int * o, int n, SEXP list, const char * str) {
  SEXP elmt = getListElement(list, str);
  int M = length(elmt); // elements to assign
  if (n < M) {
    M = n; // in case there are more elements
  }
  if (isReal(elmt)) {
    const double * xp = REAL(elmt);
    for (int j = 0; j < M; ++j) {
      if (safe2int(xp[j])) {
        o[j] = xp[j];
      }
    }
    return;
  }
  if (isInteger(elmt)) {
    const int * xp = INTEGER(elmt);
    for (int j = 0; j < M; ++j) {
      if (xp[j] != NA_INTEGER) {
        o[j] = xp[j];
      }
    }
  }
}

void setDblElement(double * o, SEXP list, const char * str) {
  SEXP elmt = getListElement(list, str);
  if (isReal(elmt)) {
    *o = asReal(elmt);
  }
  if (isInteger(elmt)) {
    *o = (double)asInteger(elmt);
  }
}

void setDblElements(double * o, int n, SEXP list, const char * str) {
  SEXP elmt = getListElement(list, str);
  int M = length(elmt); // elements to assign
  if (n < M) {
    M = n; // in case there are more elements
  }
  if (isReal(elmt)) {
    const double * xp = REAL(elmt);
    for (int j = 0; j < M; ++j) {
      if (!ISNAN(xp[j])) {
        o[j] = xp[j];
      }
    }
  }
  if (isInteger(elmt)) {
    const int * xp = INTEGER(elmt);
    for (int j = 0; j < M; ++j) {
      if (xp[j] != NA_INTEGER) {
        o[j] = xp[j];
      }
    }
  }
}

int getIntElement(SEXP List, const char * str, int ifnotfound) {
  if (!hazName(List, str)) {
    return ifnotfound;
  }
  return asInteger(getListElement(List, str));
}

double getDblElement(SEXP List, const char * str, double ifnotfound) {
  if (!hazName(List, str)) {
    return ifnotfound;
  }
  return asReal(getListElement(List, str));
}

System Sexp2System(SEXP RSystem, int yr) {
  
  if (isNull(RSystem)) {
    return yr2System(yr);
  }
  
  if (!isVectorList(RSystem)) {
    error("(Sexp2System): RSystem was type '%s' but must be type list",
          type2char(TYPEOF(RSystem)));
  }
  
  int n = length(RSystem);
  System Sys = yr2System(yr);
  if (n == 0) {
    return Sys;
  }
  // Sapto S = yr2Medicare(yr);
  if (hazName(RSystem, "yr")) {
    yr = asInteger(getListElement(RSystem, "yr"));
    Sys.yr = yr;
    // Sys.
  }
  Sys.has_sapto = yr >= 2000;
  
  // tax thresholds
  setIntElements(Sys.BRACKETS, MAX_NBRACK, RSystem, "ordinary_tax_thresholds");
  setDblElements(Sys.RATES, MAX_NBRACK, RSystem, "ordinary_tax_rates");
  
  // Set Medicare levy
  setDblElement(&Sys.M.taper, RSystem, "medicare_levy_taper");
  setDblElement(&Sys.M.rate, RSystem, "medicare_levy_rate");
  
  setIntElement(&Sys.M.lwr_single, RSystem, "medicare_levy_lower_threshold");
  setIntElement(&Sys.M.upr_single, RSystem, "medicare_levy_upper_threshold");
  
  setIntElement(&Sys.M.lwr_single_sapto, RSystem, "medicare_levy_lower_sapto_threshold");
  setIntElement(&Sys.M.upr_single_sapto, RSystem, "medicare_levy_upper_sapto_threshold");
  
  setIntElement(&Sys.M.lwr_family, RSystem, "medicare_levy_lower_family_threshold");
  setIntElement(&Sys.M.upr_family, RSystem, "medicare_levy_upper_family_threshold");
  
  setIntElement(&Sys.M.lwr_family_sapto, RSystem, "medicare_levy_lower_family_sapto_threshold");
  setIntElement(&Sys.M.upr_family_sapto, RSystem, "medicare_levy_upper_family_sapto_threshold");
  
  setIntElement(&Sys.M.lwr_thr_up_per_child, RSystem, "medicare_levy_lower_up_for_each_child");
  
  setIntElement(&Sys.M.sapto_age, RSystem, "sapto_pension_age");
  
  if (hazName(RSystem, "offsets")) {
    SEXP ROffsets = getListElement(RSystem, "offsets");
    OffsetN COffsets[MAX_N_OFFSETN] = {0};
    Sys.n_offsetn = length(ROffsets);
    SEXP2Offset(COffsets, length(ROffsets), ROffsets);
    for (int j = 0; j < length(ROffsets); ++j) {
      int nb = COffsets[j].nb;
      Sys.Offsets[j].nb = nb;
      Sys.Offsets[j].offset_1st = COffsets[j].offset_1st;
      Sys.Offsets[j].refundable = COffsets[j].refundable;
      for (int k = 0; k < MAX_OFFSETN; ++k) {
        int kk = (k < nb) ? k : nb - 1;
        Sys.Offsets[j].Thresholds[k] = COffsets[j].Thresholds[kk];
        Sys.Offsets[j].Tapers[k] = COffsets[j].Tapers[kk];
      }
    }
  }
  
  // Set Sapto
  setDblElement(&Sys.S.first_tax_rate, RSystem, "sapto_first_tax_rate");
  setIntElement(&Sys.S.lwr_couple, RSystem, "sapto_lower_threshold_married");
  setIntElement(&Sys.S.lwr_single, RSystem, "sapto_lower_threshold");
  
  setIntElement(&Sys.S.mxo_single, RSystem, "sapto_max_offset");
  setIntElement(&Sys.S.mxo_couple, RSystem, "sapto_max_offset_married");
  setDblElement(&Sys.S.pension_age, RSystem, "sapto_pension_age");
  setDblElement(&Sys.S.second_tax_rate, RSystem, "sapto_second_tax_rate");
  setDblElement(&Sys.S.taper, RSystem, "sapto_taper");
  setIntElement(&Sys.S.tax_free_thresh, RSystem, "sapto_tax_free_thresh");
  if (Sys.S.taper < 0) {
    Sys.S.taper = - Sys.S.taper;
  }
  
  Sys.S.upr_single = Sys.S.lwr_single + Sys.S.mxo_single / Sys.S.taper;
  Sys.S.upr_couple = Sys.S.lwr_couple + Sys.S.mxo_couple / Sys.S.taper;
  
  Sys.S.year = yr;
  
  return Sys;
}

static bool invalid_medicare_params(int ma, int mb, double mt, double mr) {
  int lhs = mt * (mb - ma);
  int rhs = mr * mb;
  return lhs != rhs && lhs != (rhs - 1) && lhs != (rhs + 1);
}

SEXP CvalidateSystem(SEXP RSystem, SEXP Fix) {
  if (isNull(RSystem)) {
    return R_NilValue;
  }
  
  if (!isVectorList(RSystem) || !isInteger(Fix)) {
    error("(CvalidateSystem): RSystem was type '%s' but must be type list",
          type2char(TYPEOF(RSystem)));
  }
  int fix = asInteger(Fix);
  int yr = asInteger(getListElement(RSystem, "yr"));
  SEXP Bracks = getListElement(RSystem, "ordinary_tax_thresholds");
  SEXP Rates = getListElement(RSystem, "ordinary_tax_rates");
  if (length(Bracks) && length(Rates) && length(Bracks) != length(Rates)) {
    error("`length(ordinary_tax_thresholds) = %d` yet `length(ordinary_tax_rates) = %d`. Both lengths must be equal.",
          length(Bracks), length(Rates));
  }
  System Sys = Sexp2System(RSystem, yr);
  
  // # Individuals
  //   ma <- medicare_levy_lower_threshold %|||% medicare_tbl_fy[["lower_threshold"]]
  //   mb <- medicare_levy_upper_threshold %|||% medicare_tbl_fy[["upper_threshold"]]
  //   mt <- medicare_levy_taper %|||% medicare_tbl_fy[["taper"]]
  //   mr <- medicare_levy_rate  %|||% medicare_tbl_fy[["rate"]]
  int ma = getIntElement(RSystem, "medicare_levy_lower_threshold", ml_lower_thresh(yr, false, false));
  int mb = getIntElement(RSystem, "medicare_levy_upper_threshold", ml_upper_thresh(yr, false, false));
  double mt = getDblElement(RSystem, "medicare_levy_taper", ml_taper(yr));
  double mr = getDblElement(RSystem, "medicare_levy_rate", ml_rate(yr));
  //   
  // # Individuals - SAPTO
  // # N.B. medicare_tbl_fy[["lower/upper_threshold"]] since the join above correctly identifies which ones
  //   msa <- medicare_levy_lower_sapto_threshold %|||% medicare_tbl_fy[["lower_threshold"]]
  //   msb <- medicare_levy_upper_sapto_threshold %|||% medicare_tbl_fy[["upper_threshold"]]
  int msa = getIntElement(RSystem, "medicare_levy_lower_sapto_threshold", ml_lower_thresh(yr, false, true));
  int msb = getIntElement(RSystem, "medicare_levy_upper_sapto_threshold", ml_upper_thresh(yr, false, true)); 
  //   
  //   ma <- as.integer(ma)
  //     msa <- as.integer(msa)
  //     mb <- as.integer(mb - 1)
  //     msb <- as.integer(msb - 1)
  
  // # Families
  // mfa <- medicare_levy_lower_family_threshold %|||% medicare_tbl_fy[["lower_family_threshold"]]
  // mfb <- medicare_levy_upper_family_threshold %|||% medicare_tbl_fy[["upper_family_threshold"]]
  int mfa = getIntElement(RSystem, "medicare_levy_lower_family_threshold", ml_lower_thresh(yr, true, false));
  int mfb = getIntElement(RSystem, "medicare_levy_upper_family_threshold", ml_upper_thresh(yr, true, false));
  // 
  // # Families - SAPTO
  // mfsa <- medicare_levy_lower_family_sapto_threshold %|||% medicare_tbl_fy[["lower_family_threshold"]]
  // mfsb <- medicare_levy_upper_family_sapto_threshold %|||% medicare_tbl_fy[["upper_family_threshold"]]
  int mfsa = getIntElement(RSystem, "medicare_levy_lower_family_sapto_threshold", ml_lower_thresh(yr, true, true));
  int mfsb = getIntElement(RSystem, "medicare_levy_upper_family_sapto_threshold", ml_upper_thresh(yr, true, true));
  
  errif_nonnegative(ma, "medicare_levy_lower_threshold");
  errif_nonnegative(mb, "medicare_levy_upper_threshold");
  errif_nonnegative(mfa, "medicare_levy_lower_family_threshold");
  errif_nonnegative(mfb, "medicare_levy_upper_family_threshold");
  errif_nonnegative(msa, "medicare_levy_lower_sapto_threshold");
  errif_nonnegative(msb, "medicare_levy_upper_sapto_threshold");
  errif_nonnegative(mfsa, "medicare_levy_lower_family_sapto_threshold");
  errif_nonnegative(mfsb, "medicare_levy_upper_family_sapto_threshold");
  
  if (invalid_medicare_params(ma, mb, mt, mr)) {
    if (!hazName(RSystem, "medicare_levy_upper_threshold")) {
      mb = mt * ma / (mt - mr);
      // TODO: warningcall
      warning("`medicare_levy_upper_threshold` was not specified "
                "but its default value would be inconsistent with the parameters that were specified.\n"
                "Its value has been set to:\n\t"
                "medicare_levy_upper_threshold = %d", mb);
    } else if (!hazName(RSystem, "medicare_levy_lower_threshold")) {
      ma = mb * (mt - mr) / mt;
      warning("`medicare_levy_lower_threshold` was not specified "
                "but its default value would be inconsistent with the parameters that were specified.\n"
                "Its value has been set to:\n\t"
                "medicare_levy_lower_threshold = %d", ma);
    } else if (!hazName(RSystem, "medicare_levy_taper")) {
      mt = mr * mb / (mb - ma);
      warning("`medicare_levy_taper` was not specified "
                "but its default value would be inconsistent with the parameters that were specified.\n"
                "Its value has been set to:\n\t"
                "medicare_levy_taper = %f", mt);
    } else if (!hazName(RSystem, "medicare_levy_rate")) {
      mr = mt * (mb - ma) / mb;
      warning("`medicare_levy_rate` was not specified "
                "but its default value would be inconsistent with the parameters that were specified.\n"
                "Its value has been set to:\n\t"
                "medicare_levy_rate = %f", mr);
    }
  }
  if (invalid_medicare_params(msa, msb, mt, mr)) {
    if (!hazName(RSystem, "medicare_levy_upper_sapto_threshold")) {
      msb = mt * msa / (mt - mr);
      warning("`medicare_levy_upper_sapto_threshold` was not specified "
                "but its default value would be inconsistent with the parameters that were specified.\n" 
                "Its value has been set to:\n\t"
                "medicare_levy_upper_sapto_threshold = %d", msb);
    } else if (!hazName(RSystem, "medicare_levy_lower_sapto_threshold")) {
      msa = msb * (mt - mr) / mt;
      warning("`medicare_levy_lower_sapto_threshold` was not specified "
                "but its default value would be inconsistent with the parameters that were specified.\n"
                "Its value has been set to:\n\t"
                "medicare_levy_lower_sapto_threshold = %d", msa);
    } else {
      double medicare_levy_taper_stop = mr * msb / (msb - msa);
      error("Medicare levy parameter mismatch could not be safely resolved.\n\n"
            "`medicare_levy_lower_sapto_threshold = %d` and "
            "`medicare_levy_upper_sapto_threshold = %d` were both supplied, "
            "but imply a Medicare taper rate of %f\n\t",
            msa, msb,
            medicare_levy_taper_stop);
    }
  }
  if (invalid_medicare_params(mfa, mfb, mt, mr)) {
    if (!hazName(RSystem, "medicare_levy_upper_family_threshold")) {
      mfb = mt * mfa / (mt - mr);
      warning("`medicare_levy_upper_family_threshold` was not specified "
                "but its default value would be inconsistent with the parameters that were specified.\n" 
                "Its value has been set to:\n\t"
                "medicare_levy_upper_family_threshold = %d", mfb);
    } else if (!hazName(RSystem, "medicare_levy_lower_family_threshold")) {
      mfa = mfb * (mt - mr) / mt;
      warning("`medicare_levy_lower_family_threshold` was not specified "
                "but its default value would be inconsistent with the parameters that were specified.\n"
                "Its value has been set to:\n\t"
                "medicare_levy_lower_family_threshold = %d", mfa);
    } else {
      double medicare_levy_taper_stop = mr * mfb / (mfb - mfa);
      error("Medicare levy parameter mismatch could not be safely resolved.\n\n"
              "`medicare_levy_lower_family_threshold = %d` and "
              "`medicare_levy_upper_family_threshold = %d` were both supplied, "
              "but imply a Medicare taper rate of %f\n\t",
              mfa, mfb,
              medicare_levy_taper_stop);
    }
  }
  if (invalid_medicare_params(mfsa, mfsb, mt, mr)) {
    if (!hazName(RSystem, "medicare_levy_upper_family_sapto_threshold")) {
      mfsb = mt * mfsa / (mt - mr);
      warning("`medicare_levy_upper_family_sapto_threshold` was not specified "
                "but its default value would be inconsistent with the parameters that were specified.\n" 
                "Its value has been set to:\n\t"
                "medicare_levy_upper_family_sapto_threshold = %d", mfsb);
    } else if (!hazName(RSystem, "medicare_levy_lower_family_sapto_threshold")) {
      mfsa = mfsb * (mt - mr) / mt;
      warning("`medicare_levy_lower_family_sapto_threshold` was not specified "
                "but its default value would be inconsistent with the parameters that were specified.\n"
                "Its value has been set to:\n\t"
                "medicare_levy_lower_family_sapto_threshold = %d", mfsa);
    } else {
      double medicare_levy_taper_stop = mr * mfsb / (mfsb - mfa);
      error("Medicare levy parameter mismatch could not be safely resolved.\n\n"
              "`medicare_levy_lower_family_sapto_threshold` and "
              "`medicare_levy_upper_family_sapto_threshold` were both supplied, "
              "but imply a Medicare taper rate of %f\n\t",
              medicare_levy_taper_stop);
    }
  }
  
 
  if (false) {
    print_Medicare(Sys.M);
  }
  validate_medicare(&Sys.M, fix, yr);
  
  return RSystem;
}






